<!DOCTYPE HTML>
<html lang="">


<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta name="keywords" content="（记）面试题目, viabcde">
    <meta name="description" content="java的native关键字指的是java程序调用非java代码实现的代码
常用的 文件组织方式 ： 顺序文件 、 索引文件 、 散列文件和多关键字文件顺序文件 是指按记录进入文件的先后顺序存放、其逻辑顺序和物理顺序一致的文件  多用于磁带">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>（记）面试题目 | Fox</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Fox</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>Index</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>Tags</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>Categories</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>Archives</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>About</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>Friends</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="Search"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Fox</div>
        <div class="logo-desc">
            
            好眉目生来本该住山巅
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                Index
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                Tags
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                Categories
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                Archives
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                About
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                Friends
            </a>
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/viacbde" class="waves-effect waves-light" target="_blank">
                <i class="fa fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>

        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/viacbde" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewbox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/>
    </svg>
</a>
        
    </nav>

</header>


<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/19.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        （记）面试题目
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/试题/" target="_blank">
                                <span class="chip bg-color">试题</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/编程/" class="post-category" target="_blank">
                                编程
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2018-09-17
                </div>

                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>Read Count:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="java的native关键字"><a href="#java的native关键字" class="headerlink" title="java的native关键字"></a>java的native关键字</h1><p>指的是java程序调用非java代码实现的代码</p>
<h1 id="常用的-文件组织方式-：-顺序文件-、-索引文件-、-散列文件和多关键字文件"><a href="#常用的-文件组织方式-：-顺序文件-、-索引文件-、-散列文件和多关键字文件" class="headerlink" title="常用的 文件组织方式 ： 顺序文件 、 索引文件 、 散列文件和多关键字文件"></a>常用的 文件组织方式 ： 顺序文件 、 索引文件 、 散列文件和多关键字文件</h1><p>顺序文件 是指按记录进入文件的先后顺序存放、其逻辑顺序和物理顺序一致的文件  多用于磁带<br>索引文件的组织方式：通常是在文件本身(主文件)之外，另外建立一张表，它指明逻辑记录和物理记录之间一一对应的关系，这张表就叫做 索引表 ，它和主文件 一起 构成 索引文件 。<br>索引非顺序文件中的索引表为 稠密索引 。索引顺序文件中的索引表为 稀疏索引 。若记录很大使得索引表也很大时，可对索引表再建立索引，称为 查找表 。通常可达四级索引。<br>散列文件是利用散列存储方式组织的文件，亦称为直接存取文件。它类似于散列表，即根据文件中关键字的特点，设计一个散列函数和处理冲突的方法，将记录散列到存储设备上。与散列表不同的是，对于文件来说，记录通常是成组存放的，若干个记录组成一个存储单位，称为桶。 对散列而言，处理冲突的方法主要采用拉链法。<br>多关键字文件对被查询的次关键字也建立相应的索引，则这种 包含有多个次关键字索引的文件称为 多关键字文件 。两种多关键字文件的组织方法： 多重表文件 和 倒排表 。</p>
<p>#<br>递归过程或函数调用时，处理参数和返回地址，使用的数据结构是栈  </p>
<h1 id="springboot默认json"><a href="#springboot默认json" class="headerlink" title="springboot默认json"></a>springboot默认json</h1><p>springboot默认自带json解析框架，默认使用jackson,</p>
<h1 id="maven的-scope"><a href="#maven的-scope" class="headerlink" title="maven的 scope"></a>maven的 scope</h1><p>maven的默认scope是compile</p>
<h1 id="maven的optinal"><a href="#maven的optinal" class="headerlink" title="maven的optinal"></a>maven的optinal</h1><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>dependency<span class="token operator">></span>
  <span class="token operator">&lt;</span>groupId<span class="token operator">></span>com<span class="token punctuation">.</span>itear<span class="token punctuation">.</span>projectC<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>
  <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>projectC<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>
  <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">0.0</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token operator">-</span>SNAPSHOT<span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>
  <span class="token operator">&lt;</span>optional<span class="token operator">></span><span class="token boolean">true</span><span class="token operator">&lt;</span><span class="token operator">/</span>optional<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>
</code></pre>
<p>当projectB的<code>&lt;optional&gt;true&lt;/optional&gt;</code>时, projectA中如果没有显式的引入projectC, 则projectA不依赖projectC, 即projectA可以自己选择是否依赖projectC<br>默认<code>&lt;optional&gt;</code>的值为false, 及子项目必须依赖</p>
<h1 id="数据的四种存储结构"><a href="#数据的四种存储结构" class="headerlink" title="数据的四种存储结构"></a>数据的四种存储结构</h1><p>顺序、链式、索引、散列</p>
<h1 id="两点之间最短路径算法"><a href="#两点之间最短路径算法" class="headerlink" title="两点之间最短路径算法"></a>两点之间最短路径算法</h1><p>Dijkstra(迪杰斯特拉)算法    </p>
<p>#<br>数据链路层的数据格式是帧<br>#<br>inteface方法的修饰只能是public abstract</p>
<h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">SuppressWarnings</span>
</code></pre>
<h1 id="排序算法的时间复杂度"><a href="#排序算法的时间复杂度" class="headerlink" title="排序算法的时间复杂度"></a>排序算法的时间复杂度</h1><p>除了归并排序和堆排序是nlogn 其他的都是n的平方</p>
<p>#<br>向一个长度为N的顺序表中插入—个新元素的平均时间复杂度为O(n)</p>
<p>#<br>进栈判满 出栈判空</p>
<h1 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h1><p>银行家算法是一种最有代表性的避免死锁的算法</p>
<h1 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h1><p>分组是在网络层的数据单元</p>
<h1 id="逻辑地址转为物理地址"><a href="#逻辑地址转为物理地址" class="headerlink" title="逻辑地址转为物理地址"></a>逻辑地址转为物理地址</h1><p>称为地址映射</p>
<h1 id="计算机计算三角函数"><a href="#计算机计算三角函数" class="headerlink" title="计算机计算三角函数"></a>计算机计算三角函数</h1><p>泰勒公式</p>
<p>#<br>arraylist底层数组  linklist底层双向链表<br>#<br>处理器能直接访问的 寄存器  高速缓冲  主存储器<br>#<br>主存储器的编码单位 字节</p>
<p>#<br>可以用 yum 安装软件。<br>yum install 软件名。<br>如果不知道具体的软件名，可以search一下。<br>yum search 近似软件 或内容。<br>#<br>CPU内部有一个控制存储器,里面存放着各种程序指令对应的微程序段<br>#<br>寻址方式中取得操作数速度最慢的是存储器间接寻址<br>#<br>${}原样 #{}解析传进来的数据</p>
<h1 id="序列化问题"><a href="#序列化问题" class="headerlink" title="序列化问题"></a>序列化问题</h1><h1 id="这篇文章的来源"><a href="#这篇文章的来源" class="headerlink" title="这篇文章的来源"></a>这篇文章的来源</h1><p>今天面试问到序列化问题，只知道从内存以xml/json等形式持久化到硬盘，等到要用时再从硬盘还原，重写hash和equals方法  </p>
<h1 id="为什么序列化对象通常要重写-hashCode-和-equals方法"><a href="#为什么序列化对象通常要重写-hashCode-和-equals方法" class="headerlink" title="为什么序列化对象通常要重写 hashCode 和 equals方法"></a>为什么序列化对象通常要重写 hashCode 和 equals方法</h1><p>2个内容完全一样的对象，在我们“人”看来就是一样的对象，但是计算机不这么认为，为了保证对象在进行比较时候符合人们的思维习惯，所以我们需要重写这2个方法。<br>在向 set 这种集合中添加对象的时候，set 要求对象都是不重复的，这个检查重复的过程，首先是检查对象的 hashCode() 值，如果这个值一致的话再去通过 equals 方法进行比较，如果 equals方法返回true，那么这个对象就不会被加入到 set 当中</p>
<p>#<br>对象的序列化主要有两种用途：<br>　　1） 把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；<br>　　2） 在网络上传送对象的字节序列。<br>在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。<br>当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象  </p>
<h1 id="为什么要使用SerialversionUID"><a href="#为什么要使用SerialversionUID" class="headerlink" title="为什么要使用SerialversionUID"></a>为什么要使用SerialversionUID</h1><p>如果用户没有自己声明一个serialVersionUID,接口会默认生成一个serialVersionUID<br>但是，如果我们不自己声明时，<br>当我们修改Person类的时候，Person类对应的SerialversionUID也变化了，而序列化和反序列化就是通过对比其SerialversionUID来进行的，一旦SerialversionUID不匹配，反序列化就无法成功。在实际的生产环境中，我们可能会建一系列的中间Object来反序列化我们的pojo，为了解决这个问题，我们就需要在实体类中自定义SerialversionUID<br>不管我们序列化之后如何更改我们的Person（不删除原有字段），最终都可以反序列化成功   </p>
<h2 id="Servlet-的请求流程？"><a href="#Servlet-的请求流程？" class="headerlink" title="Servlet 的请求流程？"></a><strong>Servlet 的请求流程？</strong></h2><h3 id="1-浏览器发出请求-http-localhost-80-xxx1-xxx2"><a href="#1-浏览器发出请求-http-localhost-80-xxx1-xxx2" class="headerlink" title="1.浏览器发出请求 http://localhost:80/xxx1/xxx2"></a><strong>1.浏览器发出请求</strong> <a href="http://localhost:80/xxx1/xxx2" target="_blank" rel="noopener">http://localhost:80/xxx1/xxx2</a></h3><p><strong>注：</strong>（80端口可以默认不写，因为这是http协议默认的端口，平时我们访问<a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a> 时其实访问的是<a href="https://www.baidu.com:80/）" target="_blank" rel="noopener">https://www.baidu.com:80/）</a></p>
<h3 id="2-服务器解析请求信息"><a href="#2-服务器解析请求信息" class="headerlink" title="2.服务器解析请求信息"></a><strong>2.服务器解析请求信息</strong></h3><p>•http:协议名称<br>•localhost:访问的是互联网中的哪一台计算机<br>•80:从主机当中找到对应 80 端口的程序 （这里即为 Tomcat 服务器）<br>•/xxx1:当前项目的上下文路径 （即在 server.xml 中配置主机时配置的 path属性）<br>•/xxx2:当前请求的资源名  </p>
<h3 id="3-解析-Tomcat-服务器根目录下的-config-server-xml-文件"><a href="#3-解析-Tomcat-服务器根目录下的-config-server-xml-文件" class="headerlink" title="3.解析 Tomcat 服务器根目录下的 /config/server.xml 文件"></a><strong>3.解析 Tomcat 服务器根目录下的 /config/server.xml 文件</strong></h3><pre><code>&lt;Context docBase=&quot;D:\javaPros\test\webapp&quot; path=&quot;xxx1&quot; /&gt;
</code></pre><p>判断哪一个<context>元素的 path属性 属性为 xxx1<br>•若找不到，则返回 404错误<br>•若找到了，则解析该<context>元素，得到docBase属性，获取当前访问 Web 项目的跟的绝对路径：D:\javaPros\test\webapp  </context></context></p>
<h3 id="4-从D-javaPros-test-webapp下的-WEB-INF-下找到-web-xml-文件"><a href="#4-从D-javaPros-test-webapp下的-WEB-INF-下找到-web-xml-文件" class="headerlink" title="4.从D:\javaPros\test\webapp下的 WEB-INF 下找到 web.xml 文件"></a><strong>4.从D:\javaPros\test\webapp下的 WEB-INF 下找到 web.xml 文件</strong></h3><p> 判断 web.xml 文件中是否有 <url-pattern> 的文本内容为 /xxx2<br> •若找不到，则返回 404错误<br>•若找到了，则继续获取该资源对应 Servlet 类的全限名称： xxx.xxx    </url-pattern></p>
<h3 id="5-判断-Servlet-实例缓存池-中是否有-xxx-xxx-的对象"><a href="#5-判断-Servlet-实例缓存池-中是否有-xxx-xxx-的对象" class="headerlink" title="5.判断 Servlet 实例缓存池 中是否有 xxx.xxx 的对象"></a><strong>5.判断 Servlet 实例缓存池 中是否有 xxx.xxx 的对象</strong></h3><p>Map&lt;String,Servlet&gt; cache = ……(Tomcat提供的);<br>    key:存Servlet类的全限定名称<br>    value:该Servlet类的对象.    </p>
<pre><code>Servlet obj = cache.get(&quot;xxx.xxx&quot;);
    if(obj==null){
        //Servlet实例缓存中没有该类的对象,第一次.
        GOTO 6:
    }else{
        //有对象,非第一次.
        GOTO 8:
    }
}

</code></pre><h2 id="servlet的生命周期"><a href="#servlet的生命周期" class="headerlink" title="servlet的生命周期"></a><strong>servlet的生命周期</strong></h2><h3 id="1-使用反射调用构造器，创建对应的对象"><a href="#1-使用反射调用构造器，创建对应的对象" class="headerlink" title="1.使用反射调用构造器，创建对应的对象"></a><strong>1.使用反射调用构造器，创建对应的对象</strong></h3><p>obj = Class.forName(“xxx.xxx”).newInstance();<br>把当前创建的 Servlet 对象，存放在缓存之中，供给下一次的使用.<br>cache.put(“xxx.xxx”,obj);  </p>
<h3 id="2-创建-ServletConfig-对象，并调用-init-方法"><a href="#2-创建-ServletConfig-对象，并调用-init-方法" class="headerlink" title="2.创建 ServletConfig 对象，并调用 init() 方法"></a><strong>2.创建 ServletConfig 对象，并调用 init() 方法</strong></h3><p>obj.init(config);  </p>
<h3 id="3-创建-ServletRequest-对象和-ServletResponse-对象，并调用-service-方法"><a href="#3-创建-ServletRequest-对象和-ServletResponse-对象，并调用-service-方法" class="headerlink" title="3.创建 ServletRequest 对象和 ServletResponse 对象，并调用 service()方法"></a><strong>3.创建 ServletRequest 对象和 ServletResponse 对象，并调用 service()方法</strong></h3><p>obj.service(req,resp);</p>
<h3 id="4-在-service-方法中对浏览器作出响应操作。"><a href="#4-在-service-方法中对浏览器作出响应操作。" class="headerlink" title="4.在 service() 方法中对浏览器作出响应操作。"></a><strong>4.在 service() 方法中对浏览器作出响应操作。</strong></h3><h2 id="Servlet-是单例的吗？为什么？"><a href="#Servlet-是单例的吗？为什么？" class="headerlink" title="Servlet 是单例的吗？为什么？"></a><strong>Servlet 是单例的吗？为什么？</strong></h2><p>Servlet 是单例的，浏览器多次对Servlet的请求，一般情况下，服务器只创建一个Servlet对象，也就是说，Servlet对象一旦创建了，就会驻留在内存中，为后续的请求做服务，直到服务器关闭。</p>
<h3 id="doGet与doPost方法的两个参数是什么"><a href="#doGet与doPost方法的两个参数是什么" class="headerlink" title="doGet与doPost方法的两个参数是什么"></a><strong>doGet与doPost方法的两个参数是什么</strong></h3><p>HttpServletRequest：封装请求信息<br>HttpServletResponse：封装响应信息   </p>
<h3 id="为什么get比post更快"><a href="#为什么get比post更快" class="headerlink" title="为什么get比post更快"></a><strong>为什么get比post更快</strong></h3><p>post必须等待服务器有请求回应才会发送下一个请求<br>而get则是不管有没有收到回应都不断发送请求（利用管道传输直接把多个请求发送出去，但不安全，当发送过程中服务器关闭，则之前的请求都相当于做了无用功）<br>get会缓存数据（一般是静态数据）而post不会<br>post比get安全（不会作为url的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中）</p>
<h3 id="get和post请求的区别？"><a href="#get和post请求的区别？" class="headerlink" title="get和post请求的区别？"></a><strong>get和post请求的区别？</strong></h3><p>答：<br>①get请求用来从服务器上获得资源，而post是用来向服务器提交数据；<br>②get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用”?”连接，而各个变量之间使用”&amp;”连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL；<br>③get传输的数据要受到URL长度限制（1024字节）；而post可以传输大量的数据，上传文件通常要使用post方式；<br>④使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post；<br>⑤get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是”%20”。  </p>
<h3 id="获取页面的元素的值有几种方式"><a href="#获取页面的元素的值有几种方式" class="headerlink" title="获取页面的元素的值有几种方式"></a><strong>获取页面的元素的值有几种方式</strong></h3><p>request.getParameter() 返回客户端的请求参数的值<br>request.getParameterNames() 返回所有可用属性名的枚举<br>request.getParameterValues() 返回包含参数的所有值的数组  </p>
<h3 id="request-getAttribute-和request-getParameter-区别"><a href="#request-getAttribute-和request-getParameter-区别" class="headerlink" title="request.getAttribute()和request.getParameter()区别"></a><strong>request.getAttribute()和request.getParameter()区别</strong></h3><p>用途上:<br>request.getAttribute()， 一般用于获取request域对象的数据(在跳转之前把数据使用setAttribute来放到request对象上)<br>request.getParameter()， 一般用于获取客户端提交的参数<br>存储数据上:<br>request.getAttribute()可以获取Objcet对象<br>request.getParameter()只能获取字符串(这也是为什么它一般用于获取客户端提交的参数)  </p>
<h3 id="阐述Servlet和CGI的区别"><a href="#阐述Servlet和CGI的区别" class="headerlink" title="阐述Servlet和CGI的区别?"></a><strong>阐述Servlet和CGI的区别?</strong></h3><p>Servlet与CGI的区别在于Servlet处于服务器进程中，它通过多线程方式运行其service()方法，一个实例可以服务于多个请求，并且其实例一般不会销毁，而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于Servlet。</p>
<h3 id="Servlet接口中有哪些方法？"><a href="#Servlet接口中有哪些方法？" class="headerlink" title="Servlet接口中有哪些方法？ "></a><strong>Servlet接口中有哪些方法？ </strong></h3><p>答：Servlet接口定义了5个方法，其中前三个方法与Servlet生命周期相关： </p>
<ul>
<li>void init(ServletConfig config) throws ServletException </li>
<li>void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException </li>
<li>void destory() </li>
<li>java.lang.String getServletInfo() </li>
<li>ServletConfig getServletConfig()</li>
</ul>
<p>Web容器加载Servlet并将其实例化后，Servlet生命周期开始，容器运行其init()方法进行Servlet的初始化；请求到达时调用Servlet的service()方法，service()方法会根据需要调用与请求对应的doGet或doPost等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的destroy()方法。</p>
<h3 id="纯jsp时代"><a href="#纯jsp时代" class="headerlink" title="纯jsp时代"></a><strong>纯jsp时代</strong></h3><p>使用jsp接收前台数据并通过action=”registerDeal.jsp”跳转到其他的jsp去对数据进行处理<br><img src="https://github.com/54321decba/tu/blob/master/blog/2018092808.png?raw=true" alt="enter description
here"><br>好处：简单，只有jsp,数据库<br>缺点：java逻辑全部都在jsp中，如果要用新的逻辑必须把java的逻辑按jsp重写一遍</p>
<h3 id="jsp-model-service时代"><a href="#jsp-model-service时代" class="headerlink" title="jsp+model+service时代"></a><strong>jsp+model+service时代</strong></h3><p>改进：将model 、对数据库的访问 两者与jsp分离<br><img src="https://github.com/54321decba/tu/blob/master/blog/2018092809.png?raw=true" alt="enter description
here"><br>缺点：1.每次访问数据库都要打开一次数据库;2.存在sql语句，非纯面向对象</p>
<h3 id="jsp-model-service-hibernate-时代"><a href="#jsp-model-service-hibernate-时代" class="headerlink" title="jsp+model+service(hibernate)时代"></a><strong>jsp+model+service(hibernate)时代</strong></h3><p>改进：解决了频繁连接数据库问题<br><img src="https://github.com/54321decba/tu/blob/master/blog/2018092810.png?raw=true" alt="enter description
here">  </p>
<h3 id="jsp-service-impl-dao-impl-hibernate-时代"><a href="#jsp-service-impl-dao-impl-hibernate-时代" class="headerlink" title="jsp+service+impl+dao+impl(hibernate)时代"></a><strong>jsp+service+impl+dao+impl(hibernate)时代</strong></h3><p>改进：service接口实现灵活更换各种业务；dao接口实现了灵活更换数据库<br><img src="https://github.com/54321decba/tu/blob/master/blog/2018092811.png?raw=true" alt="enter description
here"><br>缺点：处理结果的视图跳转仍然留着jsp里，视图写死在jsp</p>
<h3 id="jsp-service-impl-dao-impl-struts2-hibernate-时代"><a href="#jsp-service-impl-dao-impl-struts2-hibernate-时代" class="headerlink" title="jsp+service+impl+dao+impl(struts2+hibernate)时代"></a><strong>jsp+service+impl+dao+impl(struts2+hibernate)时代</strong></h3><p>改进：实现了视图跳转<br>!<img src="https://github.com/54321decba/tu/blob/master/blog/2018092812.png?raw=true" alt="enter description
here"><br>缺点：MVC各组件耦合度极高，即互相之间的调用写死在代码中</p>
<h3 id="jsp-service-impl-dao-impl-struts2-Spring-hibernate-时代"><a href="#jsp-service-impl-dao-impl-struts2-Spring-hibernate-时代" class="headerlink" title="jsp+service+impl+dao+impl(struts2+Spring+hibernate)时代"></a><strong>jsp+service+impl+dao+impl(struts2+Spring+hibernate)时代</strong></h3><p>改进：实现了MVC各个组件的解耦<br><img src="https://github.com/54321decba/tu/blob/master/blog/2018092813.png?raw=true" alt="enter description
here">  </p>
<h2 id="forward和redirect的区别"><a href="#forward和redirect的区别" class="headerlink" title="forward和redirect的区别"></a><strong>forward和redirect的区别</strong></h2><h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a><strong>请求转发</strong></h3><p>forword 一次请求，地址栏不变。比如你要问小李借钱，小李说没钱，但是小李帮你从小王那借了钱。<br>这样借钱的路径就一条：到小李家借钱  </p>
<h3 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a><strong>请求重定向</strong></h3><p>redirect 两次请求，地址栏变。   同样是问小李借钱，小李说没钱，但是小李告诉你小王有钱，告诉你了小王在哪，这时你就得去小王家借钱，最终借到了钱。<br>这样借钱的路径变成2条，先到小李家，再到小王家  </p>
<h3 id="forward和redirect的区别-1"><a href="#forward和redirect的区别-1" class="headerlink" title="forward和redirect的区别"></a><strong>forward和redirect的区别</strong></h3><p>•用法不同: 记住一个原则： 给服务器用的直接从资源名开始写，给浏览器用的要把应用名写上<br>◦request.getRequestDispatcher(“/资源名 URI”).forward(request,response)<br>◦转发时”/“代表的是本应用程序的根目录<br>◦response.send(“/web应用/资源名 URI”);<br>◦重定向时”/“代表的是webapps目录<br>因为他们能够去往的URL的范围不一样: ◦转发是服务器跳转只能去往当前web应用的资源，即服务器范围内<br>◦重定向是服务器跳转，可以去往任何的资源，整个网络，所以必须知名应用名<br>•传递数据的类型不同 ◦转发的request对象可以传递各种类型的数据，包括对象<br>◦重定向只能传递字符串<br>•跳转的时间不同 ◦转发时：执行到跳转语句时就会立刻跳转<br>◦重定向：整个页面执行完之后才执行跳转    </p>
<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><p>NIO( New Input/ Output) 它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆的 DirectByteBuffer 对象作为这块内存的引用进行操作，避免了在 Java 堆和 Native 堆中来回复制数据。<br>NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务。<br>同步的核心就是 Selector，Selector 代替了线程本身轮询 IO 事件，避免了阻塞同时减少了不必要的线程消耗；<br>非阻塞的核心就是通道和缓冲区，当 IO 事件就绪时，可以通过写道缓冲区，保证 IO 的成功，而无需线程阻塞式地等待。<br>特点：高效，面向块读取数据而非流，没有数据不等待而去处理其他业务</p>
<pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// CopyFile</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>*<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>*<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>channels<span class="token punctuation">.</span>*<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CopyFile</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span> String args<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
        String infile<span class="token operator">=</span><span class="token string">"E:\\北京欢迎你.txt"</span><span class="token punctuation">;</span>
        String outfile<span class="token operator">=</span><span class="token string">"E:\\out.txt"</span><span class="token punctuation">;</span>

        FileInputStream fin<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>infile<span class="token punctuation">)</span><span class="token punctuation">;</span>
        FileOutputStream fout<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>outfile<span class="token punctuation">)</span><span class="token punctuation">;</span>
        FileChannel fcin <span class="token operator">=</span> fin<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        FileChannel fcout <span class="token operator">=</span> fout<span class="token punctuation">.</span><span class="token function">getChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        ByteBuffer buffer <span class="token operator">=</span> ByteBuffer<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            buffer<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> r<span class="token operator">=</span>fcin<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            buffer<span class="token punctuation">.</span><span class="token function">flip</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            fcout<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<h1 id="使用枚举"><a href="#使用枚举" class="headerlink" title="使用枚举"></a>使用枚举</h1><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>leyou<span class="token punctuation">.</span>common<span class="token punctuation">.</span>enums<span class="token punctuation">;</span>

<span class="token keyword">import</span> lombok<span class="token punctuation">.</span>AllArgsConstructor<span class="token punctuation">;</span>
<span class="token keyword">import</span> lombok<span class="token punctuation">.</span>NoArgsConstructor<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * @author bystander
 * @date 2018/9/15
 */</span>
<span class="token annotation punctuation">@NoArgsConstructor</span>
<span class="token annotation punctuation">@AllArgsConstructor</span>
<span class="token keyword">public</span> <span class="token keyword">enum</span> ExceptionEnum <span class="token punctuation">{</span>

    <span class="token function">BRAND_CREATE_FAILED</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">"新增品牌失败"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">BRAND_NOT_FOUND</span><span class="token punctuation">(</span><span class="token number">404</span><span class="token punctuation">,</span> <span class="token string">"品牌查询失败"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">UPDATE_BRAND_FAILED</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">"品牌更新失败"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">DELETE_BRAND_EXCEPTION</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">"删除品牌失败"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

    <span class="token function">GOODS_SAVE_ERROR</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">"新增商品错误"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">GOODS_NOT_FOUND</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span> <span class="token string">"商品未查询到"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">GOODS_NOT_SALEABLE</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span> <span class="token string">"商品未上架"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">GOODS_UPDATE_ERROR</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">"商品更新失败"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">DELETE_GOODS_ERROR</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">"删除商品错误"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">UPDATE_SALEABLE_ERROR</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">"更新商品销售状态错误"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">STOCK_NOT_ENOUGH</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">"商品库存不足"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

    <span class="token function">CATEGORY_NOT_FOUND</span><span class="token punctuation">(</span><span class="token number">204</span><span class="token punctuation">,</span> <span class="token string">"分类未查询到"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">STOCK_NOT_FOUND</span><span class="token punctuation">(</span><span class="token number">204</span><span class="token punctuation">,</span> <span class="token string">"库存查询失败"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">SPU_NOT_FOUND</span><span class="token punctuation">(</span><span class="token number">201</span><span class="token punctuation">,</span> <span class="token string">"SPU未查询到"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">SKU_NOT_FOUND</span><span class="token punctuation">(</span><span class="token number">201</span><span class="token punctuation">,</span> <span class="token string">"SKU未查询到"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

    <span class="token function">RECEIVER_ADDRESS_NOT_FOUND</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span> <span class="token string">"收获地址不存在"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">ORDER_NOT_FOUND</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span> <span class="token string">"订单不存在"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">ORDER_STATUS_EXCEPTION</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">"订单状态异常"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">CREATE_PAY_URL_ERROR</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">"常见支付链接异常"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">WX_PAY_SIGN_INVALID</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span> <span class="token string">"微信支付签名异常"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">WX_PAY_NOTIFY_PARAM_ERROR</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span> <span class="token string">"微信支付回调参数异常"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

    <span class="token function">INVALID_FILE_FORMAT</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span> <span class="token string">"文件格式错误"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">UPLOAD_IMAGE_EXCEPTION</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">"文件上传异常"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">INVALID_PARAM</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span> <span class="token string">"参数错误"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">USERNAME_OR_PASSWORD_ERROR</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span> <span class="token string">"账号或密码错误"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">VERIFY_CODE_NOT_MATCHING</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span> <span class="token string">"验证码错误"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">PASSWORD_NOT_MATCHING</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span> <span class="token string">"密码错误"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">USER_NOT_EXIST</span><span class="token punctuation">(</span><span class="token number">404</span><span class="token punctuation">,</span> <span class="token string">"用户不存在"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>

    <span class="token function">SPEC_PARAM_NOT_FOUND</span><span class="token punctuation">(</span><span class="token number">204</span><span class="token punctuation">,</span> <span class="token string">"规格参数查询失败"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">UPDATE_SPEC_PARAM_FAILED</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">"商品规格参数更新失败"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">DELETE_SPEC_PARAM_FAILED</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">"商品规格参数删除失败"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">SPEC_PARAM_CREATE_FAILED</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">"新增规格参数失败"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">USER_NOT_LOGIN</span><span class="token punctuation">(</span><span class="token number">401</span><span class="token punctuation">,</span> <span class="token string">"用户未登录，请登录"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>


    <span class="token function">SPEC_GROUP_CREATE_FAILED</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">"新增规格组失败"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">SPEC_GROUP_NOT_FOUND</span><span class="token punctuation">(</span><span class="token number">204</span><span class="token punctuation">,</span> <span class="token string">"规格组查询失败"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">DELETE_SPEC_GROUP_FAILED</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">"商品规格组删除失败"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">UPDATE_SPEC_GROUP_FAILED</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token string">"商品规格组更新失败"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>


    <span class="token punctuation">;</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>
    String message<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">message</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


<span class="token punctuation">}</span>

</code></pre>
<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>leyou<span class="token punctuation">.</span>auth<span class="token punctuation">.</span>service<span class="token punctuation">;</span>

<span class="token keyword">import</span> com<span class="token punctuation">.</span>leyou<span class="token punctuation">.</span>auth<span class="token punctuation">.</span>client<span class="token punctuation">.</span>UserClient<span class="token punctuation">;</span>
<span class="token keyword">import</span> com<span class="token punctuation">.</span>leyou<span class="token punctuation">.</span>auth<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>UserInfo<span class="token punctuation">;</span>
<span class="token keyword">import</span> com<span class="token punctuation">.</span>leyou<span class="token punctuation">.</span>auth<span class="token punctuation">.</span>properties<span class="token punctuation">.</span>JwtProperties<span class="token punctuation">;</span>
<span class="token keyword">import</span> com<span class="token punctuation">.</span>leyou<span class="token punctuation">.</span>auth<span class="token punctuation">.</span>utils<span class="token punctuation">.</span>JwtUtils<span class="token punctuation">;</span>
<span class="token keyword">import</span> com<span class="token punctuation">.</span>leyou<span class="token punctuation">.</span>common<span class="token punctuation">.</span>enums<span class="token punctuation">.</span>ExceptionEnum<span class="token punctuation">;</span>
<span class="token keyword">import</span> com<span class="token punctuation">.</span>leyou<span class="token punctuation">.</span>common<span class="token punctuation">.</span>exception<span class="token punctuation">.</span>LyException<span class="token punctuation">;</span>
<span class="token keyword">import</span> com<span class="token punctuation">.</span>leyou<span class="token punctuation">.</span>user<span class="token punctuation">.</span>pojo<span class="token punctuation">.</span>User<span class="token punctuation">;</span>
<span class="token keyword">import</span> lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Slf4j<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token punctuation">.</span>context<span class="token punctuation">.</span>properties<span class="token punctuation">.</span>EnableConfigurationProperties<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Service<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * @author bystander
 * @date 2018/10/1
 */</span>
<span class="token annotation punctuation">@Slf4j</span>
<span class="token annotation punctuation">@Service</span>
<span class="token annotation punctuation">@EnableConfigurationProperties</span><span class="token punctuation">(</span>JwtProperties<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AuthService</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> UserClient userClient<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> JwtProperties props<span class="token punctuation">;</span>


    <span class="token keyword">public</span> String <span class="token function">login</span><span class="token punctuation">(</span>String username<span class="token punctuation">,</span> String password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            User user <span class="token operator">=</span> userClient<span class="token punctuation">.</span><span class="token function">queryUser</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>user <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> null<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            UserInfo userInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserInfo</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> user<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">//生成Token</span>
            String token <span class="token operator">=</span> JwtUtils<span class="token punctuation">.</span><span class="token function">generateToken</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">,</span> props<span class="token punctuation">.</span><span class="token function">getPrivateKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> props<span class="token punctuation">.</span><span class="token function">getExpire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> token<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"【授权中心】用户名和密码错误，用户名：{}"</span><span class="token punctuation">,</span> username<span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">LyException</span><span class="token punctuation">(</span>ExceptionEnum<span class="token punctuation">.</span>USERNAME_OR_PASSWORD_ERROR<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>
<h1 id="http的工作方式"><a href="#http的工作方式" class="headerlink" title="http的工作方式"></a>http的工作方式</h1><p>一个简单的通信方式<br>如果爱丽丝想给鲍伯发个消息，她会把消息绑在信鸽的腿上寄给鲍伯。然后鲍伯收到了消息，并阅读了它。这一切都是美好的。<br>但如果马洛里拦截了爱丽丝飞翔中的信鸽并且修改消息内容呢？鲍伯将无法知道爱丽丝发来的消息已经在传输过程中被修改了。<br>这就是 HTTP 的工作方式，很可怕吧？我绝不会通过 HTTP 发送我的银行凭证，希望你也不会。<br>网关 一边连着子网 替子网转发 一边连着公网上网<br>TCP必须有回复才发<br>UDP 发了不管<br>MIME(Multipurpose Internet Mail Extensions)多用途互联网邮件扩展类型  </p>
<h3 id="HTTP是无连接"><a href="#HTTP是无连接" class="headerlink" title="HTTP是无连接"></a><strong>HTTP是无连接</strong></h3><p>无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。<br>HTTP 协议这种特性优点在于解放了服务器，每一次请求“点到为止”不会造成不必要连接占用，缺点在于每次请求会传输大量重复的内容信息。<br>可以使用Keep-Alive保持连接，但缺点是占用本可以释放的空闲资源   </p>
<h3 id="HTTP协议是无状态协议"><a href="#HTTP协议是无状态协议" class="headerlink" title="HTTP协议是无状态协议"></a><strong>HTTP协议是无状态协议</strong></h3><p>无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。<br>一旦建立连接后，数据消息就通过类似Internet邮件所使用的格式<code>[RFC5322</code>]和多用途Internet邮件扩展（MIME）<code>[RFC2045]</code>来传送<br><img src="https://github.com/54321decba/tu/blob/master/201812/87.png?raw=true" alt="">     </p>
<h3 id="客户端请求："><a href="#客户端请求：" class="headerlink" title="客户端请求："></a><strong>客户端请求：</strong></h3><p>协议内容  </p>
<ul>
<li>请求（Request）</li>
<li>客户端发送一个HTTP请求到服务端的格式：</li>
<li>请求行</li>
<li>请求头</li>
<li>请求体<br><img src="http://oostc.oss-cn-shanghai.aliyuncs.com/blog/v2-054ba2c979cd2792840d99a1d0f4dc1c_hd.jpg" alt="enter description here"><pre class=" language-http"><code class="language-http">GET /hello.txt HTTP/1.1
<span class="token header-name keyword">User-Agent:</span> curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
<span class="token header-name keyword">Host:</span> www.example.com
<span class="token header-name keyword">Accept-Language:</span> en, mi
</code></pre>
<h3 id="服务端响应"><a href="#服务端响应" class="headerlink" title="服务端响应:"></a><strong>服务端响应:</strong></h3>响应（Response）</li>
<li>服务端响应客户端格式：</li>
<li>状态行</li>
<li>响应头</li>
<li>响应体<br><img src="http://oostc.oss-cn-shanghai.aliyuncs.com/blog/v2-e2447b28c4e1fd60d43bfa3976ff1531_hd.jpg" alt="enter description here"><pre><code>HTTP/1.1 200 OK
Date: Mon, 27 Jul 2009 12:28:53 GMT
Server: Apache
Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
ETag: &quot;34aa387-d-1568eb00&quot;
Accept-Ranges: bytes
Content-Length: 51
Vary: Accept-Encoding
Content-Type: text/plain
</code></pre><h3 id="http请求方法"><a href="#http请求方法" class="headerlink" title="http请求方法"></a><strong>http请求方法</strong></h3>1   GET    请求指定的页面信息，并返回实体主体。<br>2    HEAD    类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头<br>3    POST    向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。<br>4    PUT    从客户端向服务器传送的数据取代指定的文档的内容。<br>5    DELETE    请求服务器删除指定的页面。<br>6    CONNECT    HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。<br>7    OPTIONS    允许客户端查看服务器的性能。<br>8    TRACE    回显服务器收到的请求，主要用于测试或诊断。<br><a href="https://zhuanlan.zhihu.com/p/60450391" target="_blank" rel="noopener">更多详情</a><h1 id="实现会话跟踪的技术有哪些"><a href="#实现会话跟踪的技术有哪些" class="headerlink" title="实现会话跟踪的技术有哪些"></a>实现会话跟踪的技术有哪些</h1><h3 id="session的使用"><a href="#session的使用" class="headerlink" title="session的使用"></a><strong>session的使用</strong></h3>后台将value添加到session中<pre class=" language-java"><code class="language-java">session<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"username"</span><span class="token punctuation">,</span> username<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
前端获取session中的值</li>
</ul>
<pre class=" language-java"><code class="language-java">$<span class="token punctuation">{</span>username<span class="token punctuation">}</span>
</code></pre>
<h2 id="request-setAttribute-、session-setAttribute-的联系与区别"><a href="#request-setAttribute-、session-setAttribute-的联系与区别" class="headerlink" title="request.setAttribute()、session.setAttribute()的联系与区别"></a><strong>request.setAttribute()、session.setAttribute()的联系与区别</strong></h2><p>session.setAttribute()和session.getAttribute()配对使用，作用域是整个会话期间，在所有的页面都使用这些数据的时候使用。<br>request.setAttribute()和request.getAttribute()配对使用，作用域是请求和被请求页面之间。<br> <font color="red"><strong>举例</strong> </font></p>
<pre class=" language-java"><code class="language-java"> <span class="token keyword">if</span> <span class="token punctuation">(</span>resultUser <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            request<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
            request<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"errorMsg"</span><span class="token punctuation">,</span> <span class="token string">"请认真核对账号、密码！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token string">"login"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            HttpSession session <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            session<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"currentUser"</span><span class="token punctuation">,</span> resultUser<span class="token punctuation">)</span><span class="token punctuation">;</span>
            MDC<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"userName"</span><span class="token punctuation">,</span> user<span class="token punctuation">.</span><span class="token function">getUserName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token string">"redirect:/main.jsp"</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre>
<h3 id="实现会话跟踪的技术有哪些？"><a href="#实现会话跟踪的技术有哪些？" class="headerlink" title="实现会话跟踪的技术有哪些？"></a><strong>实现会话跟踪的技术有哪些？</strong></h3><p> <font color="red"><strong>为什么：</strong> </font><br>HTTP是无状态的，为了区分不同的用户，就要对用户会话进行跟踪，即为用户进行登记，为用户分配唯一的ID，服务器据此判断用户。<br>  <font color="red"><strong>①URL 重写：</strong>  </font><br>会话ID添加到URL结尾以标识<br>  <font color="red"><strong>②设置表单隐藏域：</strong>  </font><br>将和会话跟踪相关的字段添加到隐式表单域中提交给服务器。   </p>
<p><font color="red"><strong>③cookie：</strong>  </font><br>cookie有两种，一种是基于窗口的，浏览器窗口关闭后，cookie就没了；<br>另一种是存储在临时文件中，并设置时间。当建立一次会话后，会话ID就会随响应信息返回存储在基于窗口的cookie中，那就意味着只要浏览器没有关闭，会话没有超时，下一次请求时这个会话ID又会提交给服务器让服务器识别用户身份。会话中可以为用户保存信息。会话对象是在服务器内存中的，而基于窗口的cookie是在客户端内存中的。如果浏览器禁用了cookie，那么就需要通过下面两种方式进行会话跟踪。当然，在使用cookie时要注意几点：首先不要在cookie中存放敏感信息；其次cookie存储的数据量有限（4k），不能将过多的内容存储cookie中；再者浏览器通常只允许一个站点最多存放20个cookie。当然，和用户会话相关的其他信息（除了会话ID）也可以存在cookie方便进行会话跟踪。<br> <font color="red"><strong>④Session：</strong>  </font><br>在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建HttpSession，每个用户可以访问他自己的HttpSession。可以通过HttpServletRequest对象的getSession方法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象。与上面三种方式不同的是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession中的对象移到其他存储设备中，但是这样势必影响性能。添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。   </p>
<p><font color="red"><strong>补充：</strong>    </font><br>HTML5中可以使用Web Storage技术通过JavaScript来保存数据，例如可以使用localStorage和sessionStorage来保存用户会话的信息，也能够实现会话跟踪。</p>
<h3 id="在JDK1-4中引入了一个NIO的类库，使得Java涉及IO的操作拥有阻塞式和非阻塞式两种，问一下阻塞IO与非阻塞IO有什么区别？有什么优缺点？"><a href="#在JDK1-4中引入了一个NIO的类库，使得Java涉及IO的操作拥有阻塞式和非阻塞式两种，问一下阻塞IO与非阻塞IO有什么区别？有什么优缺点？" class="headerlink" title="在JDK1.4中引入了一个NIO的类库，使得Java涉及IO的操作拥有阻塞式和非阻塞式两种，问一下阻塞IO与非阻塞IO有什么区别？有什么优缺点？"></a><strong>在JDK1.4中引入了一个NIO的类库，使得Java涉及IO的操作拥有阻塞式和非阻塞式两种，问一下阻塞IO与非阻塞IO有什么区别？有什么优缺点？</strong></h3><ol>
<li>在阻塞模式下，若从网络中读取不到指定大小的数据量，阻塞IO就在那里阻塞着。比如，后面已经有10个字节的数据发过来，但是假如现在只收到8个字节，那么当前线程就在那傻傻地等待下一个字节的到来，直到把这10个字节读取完，这才将阻塞放开通行。  </li>
<li>在非阻塞模式下，若从网络流中读取不到指定大小的数据量，非阻塞IO就立即通行。比如，后面已经有10个字节的数据发过来，但是我现在只收到8个字节，那么当前线程就读取这8个字节的数据，读完后就立即返回，等另外两个字节来的时候再去读取。  <ol start="3">
<li>从上面可以看出，阻塞IO在性能方面是很低下的，如果要使用阻塞IO完成一个Web服务器的话，那么对于每一个请求都必须启用一个线程进行处理。而使用非阻塞IO的话，一到两个线程基本上就够了，因为线程不会产生阻塞，好比一下接收A请求的数据，另一下接收B请求的数据，等等，就是不停的东奔西跑，直接到把数据接收完了。  </li>
<li>虽然说，非阻塞IO比阻塞IO有更高的性能，但是对于开发来说，难度就成数倍递增了。由于是有多少数据就读取多少数据，这样在读取完整之前需要将已经读取到的数据保存起来，而且需要与其他地方来的数据隔离开来不能混在一起，否则就不知道这数据是谁的了。  </li>
</ol>
</li>
</ol>
<h2 id="下面哪些是Thread类的方法（）"><a href="#下面哪些是Thread类的方法（）" class="headerlink" title="下面哪些是Thread类的方法（）"></a><strong>下面哪些是Thread类的方法（）</strong></h2><p>A start()       B run()       C exit()       D getPriority()<br>答案：ABD<br>解析：看Java API docs吧：<a href="http://docs.oracle.com/javase/7/docs/api/，exit()是System类的方法，如System.exit(0)。" target="_blank" rel="noopener">http://docs.oracle.com/javase/7/docs/api/，exit()是System类的方法，如System.exit(0)。</a>    </p>
<h2 id="下面关于java-lang-Exception类的说法正确的是（）"><a href="#下面关于java-lang-Exception类的说法正确的是（）" class="headerlink" title="下面关于java.lang.Exception类的说法正确的是（）"></a><strong>下面关于java.lang.Exception类的说法正确的是（）</strong></h2><p>A 继承自Throwable      B Serialable      CD 不记得，反正不正确<br>答案：A<br>解析：Java异常的基类为java.lang.Throwable，java.lang.Error和java.lang.Exception继承 Throwable，RuntimeException和其它的Exception等继承Exception，具体的RuntimeException继承RuntimeException。<br>扩展：错误和异常的区别(Error vs Exception)<br>java.lang.Error: Throwable的子类，用于标记严重错误。合理的应用程序不应该去try/catch这种错误。绝大多数的错误都是非正常的，就根本不该出现的。<br>java.lang.Exception: Throwable的子类，用于指示一种合理的程序想去catch的条件。即它仅仅是一种程序运行条件，而非严重错误，并且鼓励用户程序去catch它。<br>Error和RuntimeException 及其子类都是未检查的异常（unchecked exceptions），而所有其他的Exception类都是检查了的异常（checked exceptions）.<br>checked exceptions: 通常是从一个可以恢复的程序中抛出来的，并且最好能够从这种异常中使用程序恢复。比如FileNotFoundException,    ParseException等。检查了的异常发生在编译阶段，必须要使用try…catch（或者throws）否则编译不通过。<br>unchecked exceptions: 通常是如果一切正常的话本不该发生的异常，但是的确发生了。发生在运行期，具有不确定性，主要是由于程序的逻辑问题所引起的。比如ArrayIndexOutOfBoundException, ClassCastException等。从语言本身的角度讲，程序不该去catch这类异常，虽然能够从诸如RuntimeException这样的异常中catch并恢复，但是并不鼓励终端程序员这么做，因为完全没要必要。因为这类错误本身就是bug，应该被修复，出现此类错误时程序就应该立即停止执行。 因此，面对Errors和unchecked exceptions应该让程序自动终止执行，程序员不该做诸如try/catch这样的事情，而是应该查明原因，修改代码逻辑。<br>RuntimeException：RuntimeException体系包括错误的类型转换、数组越界访问和试图访问空指针等等。<br>处理RuntimeException的原则是：如果出现 RuntimeException，那么一定是程序员的错误。例如，可以通过检查数组下标和数组边界来避免数组越界访问异常。其他（IOException等等）checked异常一般是外部错误，例如试图从文件尾后读取数据等，这并不是程序本身的错误，而是在应用环境中出现的外部错误。                </p>
<h2 id="下列说法正确的是（）"><a href="#下列说法正确的是（）" class="headerlink" title="下列说法正确的是（）"></a><strong>下列说法正确的是（）</strong></h2><p>A LinkedList继承自List<br>B AbstractSet继承自Set<br>C HashSet继承自AbstractSet<br>D WeakMap继承自HashMap<br>答案：AC       </p>
<h2 id="存在使i-1-lt-i的数吗（）"><a href="#存在使i-1-lt-i的数吗（）" class="headerlink" title="存在使i + 1 &lt; i的数吗（）"></a><strong>存在使i + 1 &lt; i的数吗（）</strong></h2><p>答案：存在<br>解析：如果i为int型，那么当i为int能表示的最大整数时，i+1就溢出变成负数了，此时不就&lt;i了吗。<br>扩展：存在使i &gt; j || i &lt;= j不成立的数吗（）<br>答案：存在<br>解析：比如Double.NaN或Float.NaN，感谢@BuilderQiu网友指出。<br><strong>下面哪个流类属于面向字符的输入流(  )</strong><br>A  BufferedWriter           B  FileInputStream          C  ObjectInputStream          D  InputStreamReader<br> 答案：D<br> 解析：Java的IO操作中有面向字节(Byte)和面向字符(Character)两种方式。<br> 面向字节的操作为以8位为单位对二进制的数据进行操作，对数据不进行转换，这些类都是InputStream和OutputStream的子类。<br> 面向字符的操作为以字符为单位对数据进行操作，在读的时候将二进制数据转为字符，在写的时候将字符转为二进制数据，这些类都是Reader和Writer的子类。<br>总结：以InputStream（输入）/OutputStream（输出）为后缀的是字节流；<br>          以Reader（输入）/Writer（输出）为后缀的是字符流。<br>扩展：Java流类图结构，一目了然，解决大部分选择题：<br><strong>Java接口的修饰符可以为（）</strong><br>A private     B protected     C final       D abstract<br>答案：CD<br>解析：接口很重要，为了说明情况，这里稍微啰嗦点：<br>（1）接口用于描述系统对外提供的所有服务,因此接口中的成员常量和方法都必须是公开(public)类型的,确保外部使用者能访问它们；<br>（2）接口仅仅描述系统能做什么,但不指明如何去做,所以接口中的方法都是抽象(abstract)方法；<br>（3）接口不涉及和任何具体实例相关的细节,因此接口没有构造方法,不能被实例化,没有实例变量，只有静态（static）变量；<br>（4）接口的中的变量是所有实现类共有的，既然共有，肯定是不变的东西，因为变化的东西也不能够算共有。所以变量是不可变(final)类型，也就是常量了。<br>（5） 接口中不可以定义变量？如果接口可以定义变量，但是接口中的方法又都是抽象的，在接口中无法通过行为来修改属性。有的人会说了，没有关系，可以通过 实现接口的对象的行为来修改接口中的属性。这当然没有问题，但是考虑这样的情况。如果接口 A 中有一个public 访问权限的静态变量 a。按照 Java 的语义，我们可以不通过实现接口的对象来访问变量 a，通过 A.a = xxx; 就可以改变接口中的变量 a 的值了。正如抽象类中是可以这样做的，那么实现接口 A 的所有对象也都会自动拥有这一改变后的 a 的值了，也就是说一个地方改变了 a，所有这些对象中 a 的值也都跟着变了。这和抽象类有什么区别呢，怎么体现接口更高的抽象级别呢，怎么体现接口提供的统一的协议呢，那还要接口这种抽象来做什么呢？所以接口中 不能出现变量，如果有变量，就和接口提供的统一的抽象这种思想是抵触的。所以接口中的属性必然是常量，只能读不能改，这样才能为实现接口的对象提供一个统 一的属性。<br>通俗的讲，你认为是要变化的东西，就放在你自己的实现中，不能放在接口中去，接口只是对一类事物的属性和行为更高层次的抽象。对修改关闭，对扩展（不同的实现 implements）开放，接口是对开闭原则的一种体现。<br>所以：<br>接口的方法默认是public abstract；<br>接口中不可以定义变量即只能定义常量(加上final修饰就会变成常量)。所以接口的属性默认是public static final 常量，且必须赋初值。<br>注意：final和abstract不能同时出现。<br><strong>不通过构造函数也能创建对象吗（）</strong><br>A 是     B 否<br>答案：A<br>解析：Java创建对象的几种方式（重要）：<br>(1) 用new语句创建对象，这是最常见的创建对象的方法。<br>(2) 运用反射手段,调用java.lang.Class或者java.lang.reflect.Constructor类的newInstance()实例方法。<br>(3) 调用对象的clone()方法。<br>(4) 运用反序列化手段，调用java.io.ObjectInputStream对象的 readObject()方法。<br>(1)和(2)都会明确的显式的调用构造函数 ；(3)是在内存上对已有对象的影印，所以不会调用构造函数 ；(4)是从文件中还原类的对象，也不会调用构造函数。<br><strong>ArrayList list = new ArrayList(20);中的list扩充几次（）</strong><br>A 0     B 1     C 2      D 3<br>答案：A<br>解析：这里有点迷惑人，大家都知道默认ArrayList的长度是10个，所以如果你要往list里添加20个元素肯定要扩充一次（扩充为原来的1.5倍），但是这里显示指明了需要多少空间，所以就一次性为你分配这么多空间，也就是不需要扩充了。<br><strong>下面哪些是对称加密算法（）</strong><br>A DES   B AES   C DSA   D RSA<br>答案：AB<br>解析：常用的对称加密算法有：DES、3DES、RC2、RC4、AES<br>常用的非对称加密算法有：RSA、DSA、ECC<br>使用单向散列函数的加密算法：MD5、SHA<br>18.新建一个流对象，下面哪个选项的代码是错误的？（）<br>A）new BufferedWriter(new FileWriter(“a.txt”));<br>B）new BufferedReader(new FileInputStream(“a.dat”));<br>C）new GZIPOutputStream(new FileOutputStream(“a.zip”));<br>D）new ObjectInputStream(new FileInputStream(“a.dat”));<br>答案：B<br>解析：请记得13题的那个图吗？Reader只能用FileReader进行实例化。<br><strong>下面程序能正常运行吗（）</strong>    </p>
<pre><code>public class NULL {
    public static void haha(){
        System.out.println(&quot;haha&quot;);
    }
    public static void main(String[] args) {
        ((NULL)null).haha();
    }
}
</code></pre><p>答案：能正常运行<br>解析：输出为haha，因为null值可以强制转换为任何java类类型,(String)null也是合法的。但null强制转换后是无效对象，其返回值还是为null，而static方法的调用是和类名绑定的，不借助对象进行访问所以能正确输出。反过来，没有static修饰就只能用对象进行访问，使用null调用对象肯定会报空指针错了。这里和C++很类似。这里感谢@Florian网友解答。<br><strong>下面程序的运行结果是什么（）</strong>   </p>
<pre><code>class HelloA {
    public HelloA() {
        System.out.println(&quot;HelloA&quot;);
    }
    { System.out.println(&quot;I&#39;m A class&quot;); }
    static { System.out.println(&quot;static A&quot;); }
}
public class HelloB extends HelloA {
    public HelloB() {
        System.out.println(&quot;HelloB&quot;);
    }    
    { System.out.println(&quot;I&#39;m B class&quot;); }    
    static { System.out.println(&quot;static B&quot;); }    
    public static void main(String[] args) { 
　　　　 new HelloB(); 
　　 }
}
</code></pre><p>答案：<br>static A<br>static B<br>I’m A class<br>HelloA<br>I’m B class<br>HelloB<br>解析：说实话我觉得这题很好，考查静态语句块、构造语句块（就是只有大括号的那块）以及构造函数的执行顺序。<br>对象的初始化顺序：（1）类加载之后，按从上到下（从父类到子类）执行被static修饰的语句；（2）当static语句执行完之后,再执行main方法；（3）如果有语句new了自身的对象，将从上到下执行构造代码块、构造器（两者可以说绑定在一起）。<br>下面稍微修改下上面的代码，以便更清晰的说明情况：<br>View Code<br>此时输出结果为：   </p>
<pre><code>static A
static B
-------main start-------
I&#39;m A class
HelloA
I&#39;m B class
HelloB
I&#39;m A class
HelloA
I&#39;m B class
HelloB
-------main end-------
</code></pre><p><strong>getCustomerInfo()方法如下，try中可以捕获三种类型的异常，如果在该方法运行中产生了一个IOException，将会输出什么结果（）</strong>    </p>
<pre><code>    public void getCustomerInfo() {
        try {
            // do something that may cause an Exception
        } catch (java.io.FileNotFoundException ex) {
            System.out.print(&quot;FileNotFoundException!&quot;);
        } catch (java.io.IOException ex) {
            System.out.print(&quot;IOException!&quot;);
        } catch (java.lang.Exception ex) {
            System.out.print(&quot;Exception!&quot;);
        }
    }
</code></pre><p>A IOException!<br>BIOException!Exception!<br>CFileNotFoundException!IOException!<br>DFileNotFoundException!IOException!Exception!<br>答案：A<br>解析：考察多个catch语句块的执行顺序。当用多个catch语句时，catch语句块在次序上有先后之分。从最前面的catch语句块依次先后进行异常类型匹配，这样如果父异常在子异常类之前，那么首先匹配的将是父异常类，子异常类将不会获得匹配的机会，也即子异常类型所在的catch语句块将是不可到达的语句。所以，一般将父类异常类即Exception老大放在catch语句块的最后一个。<br><strong>下面代码的运行结果为：（）</strong>   </p>
<pre><code>import java.io.*;
import java.util.*;
public class foo{
    public static void main (String[] args){
        String s;
        System.out.println(&quot;s=&quot; + s);
    }
}
</code></pre><p>A 代码得到编译，并输出“s=”<br>B 代码得到编译，并输出“s=null”<br>C 由于String s没有初始化，代码不能编译通过<br>D 代码得到编译，但捕获到 NullPointException异常<br>答案：C<br>解析：开始以为会输出null什么的，运行后才发现Java中所有定义的基本类型或对象都必须初始化才能输出值。<br>  <strong>System.out.println(“5” + 2);的输出结果应该是（）。</strong><br>A 52                   B7                     C2                     D5<br>答案：A<br>解析：没啥好说的，Java会自动将2转换为字符串。<br> <strong>指出下列程序运行的结果 （）</strong>  </p>
<pre><code>public class Example {
    String str = new String(&quot;good&quot;);
    char[] ch = { &#39;a&#39;, &#39;b&#39;, &#39;c&#39; };
    public static void main(String args[]) {
        Example ex = new Example();
        ex.change(ex.str, ex.ch);
        System.out.print(ex.str + &quot; and &quot;);
        System.out.print(ex.ch);
    }
    public void change(String str, char ch[]) {
        str = &quot;test ok&quot;;
        ch[0] = &#39;g&#39;;
    }
}
</code></pre><p>A、 good and abc<br>B、 good and gbc<br>C、 test ok and abc<br>D、 test ok and gbc<br>答案：B<br>解析：大家可能以为Java中String和数组都是对象所以肯定是对象引用，然后就会选D，其实这是个很大的误区：因为在java里没有引用传递，只有值传递<br>这个值指的是实参的地址的拷贝，得到这个拷贝地址后，你可以通过它修改这个地址的内容（引用不变），因为此时这个内容的地址和原地址是同一地址，<br>但是你不能改变这个地址本身使其重新引用其它的对象，也就是值传递，可能说的不是很清楚，下面给出一个完整的能说明情况的例子吧：<br>程序有些啰嗦，但能反映问题，该程序运行结果为：  </p>
<pre><code>对象交换前：p1 = Alexia female
对象交换前：p2 = Edward male

对象交换后：p1 = Alexia female
对象交换后：p2 = Edward male

对象数组交换前：arraya[0] = Alexia female, arraya[1] = Edward male
对象数组交换前：arrayb[0] = jmwang female, arrayb[1] = hwu male

对象数组交换后：arraya[0] = Alexia female, arraya[1] = Edward male
对象数组交换后：arrayb[0] = jmwang female, arrayb[1] = hwu male

基本类型数组交换前：a[0] = 0, a[1] = 1
基本类型数组交换前：b[0] = 1, b[1] = 2

基本类型数组交换后：a[0] = 0, a[1] = 1
基本类型数组交换后：b[0] = 1, b[1] = 2

对象数组内容交换并改变后：arraya[1] = wjl male
对象数组内容交换并改变后：arrayb[1] = Edward male

基本类型数组内容交换并改变后：a[1] = 5
基本类型数组内容交换并改变后：b[1] = 1
</code></pre><p>说明：不管是对象、基本类型还是对象数组、基本类型数组，在函数中都不能改变其实际地址但能改变其中的内容。<br><strong>要从文件”file.dat”中读出第10个字节到变量c中,下列哪个方法适合? （）</strong><br>A FileInputStream in=new FileInputStream(“file.dat”); in.skip(9); int c=in.read();<br>B FileInputStream in=new FileInputStream(“file.dat”); in.skip(10); int c=in.read();<br>C FileInputStream in=new FileInputStream(“file.dat”); int c=in.read();<br>D RandomAccessFile in=new RandomAccessFile(“file.dat”); in.skip(9); int c=in.readByte();<br>答案：A?D?<br>解析：long skip(long n)作用是跳过n个字节不读，主要用在包装流中的，因为一般流（如FileInputStream）只能顺序一个一个的读不能跳跃读，但是包装流可以用skip方法跳跃读取。那么什么是包装流呢？各种字节节点流类，它们都只具有读写字节内容的方法，以FileInputStream与FileOutputStream为例，它们只能在文件中读取或者向文件中写入字节，在实际应用中我们往往需要在文件中读取或者写入各种类型的数据，就必须先将其他类型的数据转换成字节数组后写入文件，或者从文件中读取到的字节数组转换成其他数据类型，想想都很麻烦！！因此想通过FileOutputStream将一个浮点小数写入到文件中或将一个整数写入到文件时是非常困难的。这时就需要包装类DataInputStream/DataOutputStream，它提供了往各种输入输出流对象中读入或写入各种类型的数据的方法。<br>DataInputStream/DataOutputStream并没有对应到任何具体的流设备，一定要给它传递一个对应具体流设备的输入或输出流对象，完成类似 DataInputStream/DataOutputStream功能的类就是一个包装类，也叫过滤流类或处理流类。它对InputOutStream/OutputStream流类进行了包装，使编程人员使用起来更方便。其中DataInputStream包装类的构造函数语法：public DataInputStream(InputStream in)。包装类也可以包装另外一个包装类。<br>首先BC肯定 是错的，那A正确吗？按上面的解析应该也不对，但我试了下，发现A也是正确的，与网上解析的资料有些出入，下面是我的code：<br>那么D呢，RandomAccessFile是IO包的类，但是其自成一派，从Object直接继承而来。可以对文件进行读取和写入。支持文件的随机访问，即可以随机读取文件中的某个位置内容，这么说RandomAccessFile肯定可以达到题目的要求，但是选项有些错误，比如RandomAccessFile的初始化是两个参数而非一个参数，采用的跳跃读取方法是skipBytes()而非skip()，即正确的写法是：<br>RandomAccessFile in = new RandomAccessFile(“file.dat”, “r”);<br>in.skipBytes(9);<br>int c = in.readByte();<br>这样也能读到第十个字节，也就是A和D都能读到第十个字节，那么到底该选哪个呢？A和D有啥不同吗？求大神解答~~~<br><strong>下列哪种异常是检查型异常，需要在编写程序时声明 （）</strong><br>ANullPointerException        BClassCastException      CFileNotFoundException       D IndexOutOfBoundsException<br>答案：C<br>解析：看第2题的解析。<br><strong>下面的方法，当输入为2的时候返回值是多少?（）</strong>    </p>
<pre><code>    public static int getValue(int i) {
        int result = 0;
        switch (i) {
        case 1:
            result = result + i;
        case 2:
            result = result + i * 2;
        case 3:
            result = result + i * 3;
        }
        return result;
    }
</code></pre><p>A0                    B2                    C4                     D10<br>答案：D<br>解析：注意这里case后面没有加break，所以从case 2开始一直往下运行。<br><strong>选项中哪一行代码可以替换题目中//add code here而不产生编译错误？（）</strong>   </p>
<pre><code>public abstract class MyClass {
     public int constInt = 5;
     //add code here
     public void method() {
     }
}
</code></pre><p>Apublic abstract void method(int a);<br>B constInt = constInt + 5;<br>C public int method();<br>D public abstract void anotherMethod() {}<br>答案：A<br>解析：考察抽象类的使用。<br>抽象类遵循的原则：<br>（1）abstract关键字只能修饰类和方法，不能修饰字段。<br>（2）抽象类不能被实例化（无法使用new关键字创建对象实例），只能被继承。<br>（3）抽象类可以包含属性，方法，构造方法，初始化块，内部类，枚举类，和普通类一样，普通方法一定要实现，变量可以初始化或不初始化但不能初始化后在抽象类中重新赋值或操作该变量（只能在子类中改变该变量）。<br>（4）抽象类中的抽象方法（加了abstract关键字的方法）不能实现。<br>（5）含有抽象方法的类必须定义成抽象类。<br>扩展：抽象类和接口的区别，做个总结吧：<br>（1）接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的。   </p>
<p>（2）abstract class 在 Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface，实现多重继承。接口还有标识（里面没有任何方法，如Remote接口）和数据共享（里面的变量全是常量）的作用。   </p>
<p>（3）在abstract class 中可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface中，只能够有静态的不能被修改的数据成员（也就是必须是 static final的，不过在 interface中一般不定义数据成员），所有的成员方法默认都是 public abstract 类型的。  </p>
<p>（4）abstract class和interface所反映出的设计理念不同。其实abstract class表示的是”is-a”关系，interface表示的是”has-a”关系。   </p>
<p>（5）实现接口的一定要实现接口里定义的所有方法，而实现抽象类可以有选择地重写需要用到的方法，一般的应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现。抽象类中可以有非抽象方法。接口中则不能有实现方法。   </p>
<p>（6）接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以在子类中重新赋值。<br><strong>阅读Shape和Circle两个类的定义。在序列化一个Circle的对象circle到文件时，下面哪个字段会被保存到文件中？ (  )</strong>    </p>
<pre><code>class Shape {
       public String name;
}
class Circle extends Shape implements Serializable{
       private float radius;
       transient int color;
       public static String type = &quot;Circle&quot;;
}
</code></pre><p>Aname<br>B radius<br>C color<br>D type<br>答案：B<br>解析：这里有详细的解释：<a href="http://www.cnblogs.com/lanxuezaipiao/p/3369962.html" target="_blank" rel="noopener">http://www.cnblogs.com/lanxuezaipiao/p/3369962.html</a><br><strong>下面是People和Child类的定义和构造方法，每个构造方法都输出编号。在执行new Child(“mike”)的时候都有哪些构造方法被顺序调用？请选择输出结果 ( )</strong>       </p>
<pre><code>class People {
    String name;
    public People() {
        System.out.print(1);
    }
    public People(String name) {
        System.out.print(2);
        this.name = name;
    }
}
class Child extends People {
    People father;
    public Child(String name) {
        System.out.print(3);
        this.name = name;
        father = new People(name + &quot;:F&quot;);
    }
    public Child() {
        System.out.print(4);
    }
}
</code></pre><p>A312              B 32               C 432              D 132<br>答案：D<br>解析：考察的又是父类与子类的构造函数调用次序。在Java中，子类的构造过程中必须调用其父类的构造函数，是因为有继承关系存在时，子类要把父类的内容继承下来。但如果父类有多个构造函数时，该如何选择调用呢？<br>第一个规则：子类的构造过程中，必须调用其父类的构造方法。一个类，如果我们不写构造方法，那么编译器会帮我们加上一个默认的构造方法（就是没有参数的构造方法），但是如果你自己写了构造方法，那么编译器就不会给你添加了，所以有时候当你new一个子类对象的时候，肯定调用了子类的构造方法，但是如果在子类构造方法中我们并没有显示的调用基类的构造方法，如：super();  这样就会调用父类没有参数的构造方法。<br>第二个规则：如果子类的构造方法中既没有显示的调用基类构造方法，而基类中又没有无参的构造方法，则编译出错，所以，通常我们需要显示的：super(参数列表)，来调用父类有参数的构造函数，此时无参的构造函数就不会被调用。<br>总之，一句话：子类没有显示调用父类构造函数，不管子类构造函数是否带参数都默认调用父类无参的构造函数，若父类没有则编译出错。<br>最后，给大家出个思考题：下面程序的运行结果是什么？    </p>
<pre><code>public class Dervied extends Base {
    private String name = &quot;dervied&quot;;
    public Dervied() {
        tellName();
        printName();
    }
    public void tellName() {
        System.out.println(&quot;Dervied tell name: &quot; + name);
    }    
    public void printName() {
        System.out.println(&quot;Dervied print name: &quot; + name);
    }
    public static void main(String[] args){

        new Dervied();    
    }
}
class Base {    
    private String name = &quot;base&quot;;
    public Base() {
        tellName();
        printName();
    }   
    public void tellName() {
        System.out.println(&quot;Base tell name: &quot; + name);
    }    
    public void printName() {
        System.out.println(&quot;Base print name: &quot; + name);
    }
}

</code></pre><h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a><strong>编程题</strong></h1><h3 id="求二进制中1的个数"><a href="#求二进制中1的个数" class="headerlink" title="求二进制中1的个数"></a>求二进制中1的个数</h3><p>先普及一哈位逻辑运算符的知识  </p>
<table>
<thead>
<tr>
<th>OP1</th>
<th>OP2</th>
<th>&amp;</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>同为1时结果才为1  </p>
<table>
<thead>
<tr>
<th>OP1</th>
<th>OP1</th>
<th>I</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>有1结果才为1  </p>
<table>
<thead>
<tr>
<th>OP1</th>
<th>OP2</th>
<th>^</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>不同时结果才为1  </p>
<h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>n&amp;1的是意思 判断最后一位是否为1</p>
<pre><code>public class Test{
    public static int countOne(int n) {
        int count=0;
        while(n&gt;0) {
            if((n&amp;1)==1)
                count++;
            n&gt;&gt;=1;
        }
        return count;
    } 
}
</code></pre><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><pre><code>public class Test{
    public static int countOne(int n) {
        int count=0;
        while(n&gt;0) {
            if(n!=0)
                n=n&amp;(n-1);
                count++;
        }
        return count;
    } 
}
</code></pre><h3 id="统计一行字符中有多少个单词"><a href="#统计一行字符中有多少个单词" class="headerlink" title="统计一行字符中有多少个单词"></a>统计一行字符中有多少个单词</h3><p>判断每个字符是否为空 空则count+1 不空则继续往后判断</p>
<pre><code>public class Test_plus {
    public static int wordCount(String s) {
        int word=0;
        int count=0;
        for(int i=0;i&lt;s.length();i++) {
            if(s.charAt(i)==&#39; &#39;)
                word=0;
            else if(word==0) {//非空格且 word不等于0则word设为1 
                word=1;
                count++;
            }
        }
        return count;
    }
}
</code></pre><h3 id="判断一个数是否是2的n次方"><a href="#判断一个数是否是2的n次方" class="headerlink" title="判断一个数是否是2的n次方"></a>判断一个数是否是2的n次方</h3><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p>从1即2^0 开始与n比较 相等则返回true  每次往左移一位 2^1 2^2依次比较</p>
<pre><code>public class Test{
    public static boolean isPower(int n) {
        if(n&lt;1)return false;
        int i=1;
        while(i&lt;=n) {
            if(i==n)return true;
            i&lt;&lt;=1;
        }
        return false;
    }
}
</code></pre><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><pre><code>public class Test{
    public static boolean isPower(int n) {
    if(n&lt;1)return false;
    int m=n&amp;(n-1);
    return m==0;
    }
}
</code></pre><h3 id="不用比较运算得到2个数中的较大或较小的值"><a href="#不用比较运算得到2个数中的较大或较小的值" class="headerlink" title="不用比较运算得到2个数中的较大或较小的值"></a>不用比较运算得到2个数中的较大或较小的值</h3><p>a+b加上差值 或减去差值 再除以2 妙不可言！牛批！</p>
<pre><code>public class Test_plus {
    public static int max(int a,int b) {
        return (a+b+Math.abs(a-b))/2;
    }
    public static int min(int a,int b) {
        return(a+b-Math.abs(a-b))/2;
    }
}


</code></pre><h3 id="移位运算实现最快乘法"><a href="#移位运算实现最快乘法" class="headerlink" title="移位运算实现最快乘法"></a>移位运算实现最快乘法</h3><pre><code>public calss Muti{
//n表示左移的次数 ，用循环来控制左移 每次左移一次
    public static int powerN(int m,int n){
        for(int i=0;i&lt;n;i++)
            m=m&lt;&lt;1;
            return m;
    }
    public static void main(String[] args){
        System.out.println(&quot;3 * 8 = &quot;+powerN(3,3));
    }

}
</code></pre><h3 id="古典问题有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第四个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？"><a href="#古典问题有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第四个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？" class="headerlink" title="古典问题有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第四个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？"></a>古典问题有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第四个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？</h3><p>程序分析：   兔子的规律为数列1,1,2,3,5,8,13,21….<br>因此，可以使用递归 除了前2个返回是1要单独写之外 从第3个开始递归 该位置的值等于其前2个的值加和</p>
<pre><code>public class exp2{
    public static void main(String args[]){
        int i=0;
        math mymath = new math();
        for(i=1;i&lt;=20;i++)
            System.out.println(mymath.f(i));
    }

}
class math
{
    public int f(int x)
    {
        if(x==1 || x==2)
            return 1;
        else
            return f(x-1)+f(x-2);
    }
}
</code></pre><h3 id="打印出所有的-“水仙花数-“，所谓-“水仙花数-“是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个-“水仙花数-“，因为153-1的三次方＋5的三次方＋3的三次方。"><a href="#打印出所有的-“水仙花数-“，所谓-“水仙花数-“是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个-“水仙花数-“，因为153-1的三次方＋5的三次方＋3的三次方。" class="headerlink" title="打印出所有的 “水仙花数 “，所谓 “水仙花数 “是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个 “水仙花数 “，因为153=1的三次方＋5的三次方＋3的三次方。"></a>打印出所有的 “水仙花数 “，所谓 “水仙花数 “是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个 “水仙花数 “，因为153=1的三次方＋5的三次方＋3的三次方。</h3><p>1.程序分析：利用for循环控制100-999个数，每个数分解出个位，十位，百位。<br>     取百位数 ：小数点后的数省略  i=x / 100;</p>
<p>  取十位数 ：先取余数再省略小数点后的数     j=(x % 100) /10;</p>
<p> 取个位数 ：      k=x % 10;</p>
<pre><code>public class exp2{

    public static void main(String args[]){

       int i=0;

       math mymath = new math();

       for(i=100;i&lt;=999;i++)

           if(mymath.shuixianhua(i)==true)

           System.out.println(i);

    }

}

class math

{
    public boolean shuixianhua(int x)

    {

       int i=0,j=0,k=0;

       i=x / 100;

       j=(x % 100) /10;

       k=x % 10;

       if(x==i*i*i+j*j*j+k*k*k)

          return true;

       else

          return false;
    }

}
</code></pre><h3 id="将一个正整数分解质因数。例如：输入90-打印出90-233-5。【不是很懂】"><a href="#将一个正整数分解质因数。例如：输入90-打印出90-233-5。【不是很懂】" class="headerlink" title="将一个正整数分解质因数。例如：输入90,打印出90=233*5。【不是很懂】"></a>将一个正整数分解质因数。例如：输入90,打印出90=2<em>3</em>3*5。【不是很懂】</h3><p>程序分析：对n进行分解质因数，应先找到一个最小的质数k，然后按下述步骤完成：</p>
<p>(1)如果这个质数恰等于n，则说明分解质因数的过程已经结束，打印出即可。</p>
<p>(2)如果n &lt;&gt; k，但n能被k整除，则应打印出k的值，并用n除以k的商,作为新的正整数你,重复执行第一步。</p>
<p>(3)如果n不能被k整除，则用k+1作为k的值,重复执行第一步。</p>
<pre><code>public class exp2{
    public exp2(){}
    public void fengjie(int n){
        for(int i=2;i&lt;=n/2;i++){
            if(n%i==0){
                System.out.print(i+&quot;*&quot;);
                fengjie(n/i);
                }
        }
        System.out.print(n);
        System.exit(0);///不能少这句，否则结果会出错
        }
        public static void main(String[] args){
             String str=&quot;&quot;;
             exp2 c=new exp2();
             str=javax.swing.JOptionPane.showInputDialog(&quot;请输入N的值（输入exit退出）：&quot;);
             int N;
             N=0;
             try{
                     N=Integer.parseInt(str);
                     }catch(NumberFormatException e){
                         e.printStackTrace();
                         }
            System.out.print(N+&quot;分解质因数：&quot;+N+&quot;=&quot;);
            c.fengjie(N);
        }   
}
</code></pre><h3 id="【算法真的是妙不可言啊！】利用条件运算符的嵌套来完成此题：学习成绩-gt-90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。"><a href="#【算法真的是妙不可言啊！】利用条件运算符的嵌套来完成此题：学习成绩-gt-90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。" class="headerlink" title="【算法真的是妙不可言啊！】利用条件运算符的嵌套来完成此题：学习成绩&gt; =90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。"></a>【算法真的是妙不可言啊！】利用条件运算符的嵌套来完成此题：学习成绩&gt; =90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。</h3><p>1.程序分析：(a&gt; b)?a:b这是条件运算符的基本例子。</p>
<pre><code>import javax.swing.*;

public class ex5 {

        public static void main(String[] args){

             String str=&quot;&quot;;

             str=JOptionPane.showInputDialog(&quot;请输入N的值（输入exit退出）：&quot;);

             int N;

             N=0;

             try{

                N=Integer.parseInt(str);

              }

             catch(NumberFormatException e){

                e.printStackTrace();

               }

             str=(N&gt;90?&quot;A&quot;:(N&gt;60?&quot;B&quot;:&quot;C&quot;));

             System.out.println(str);

        }  

}
</code></pre><h3 id="输入两个正整数m和n，求其最大公约数和最小公倍数。"><a href="#输入两个正整数m和n，求其最大公约数和最小公倍数。" class="headerlink" title="输入两个正整数m和n，求其最大公约数和最小公倍数。"></a>输入两个正整数m和n，求其最大公约数和最小公倍数。</h3><p>1.程序分析：利用辗除法。 </p>
<pre><code>最大公约数：
public class CommonDivisor{
    public static void main(String args[])
    {
        commonDivisor(24,32);
    }
    static int commonDivisor(int M, int N)
    {
        if(N&lt;0||M&lt;0)
        {
            System.out.println(&quot;ERROR!&quot;);
            return -1;
        }
        if(N==0)
        {
            System.out.println(&quot;the biggest common divisor is :&quot;+M);
            return M;
        }
        return commonDivisor(N,M%N);
    }
}
最小公倍数和最大公约数：
import java.util.Scanner;
public class CandC
{
//下面的方法是求出最大公约数
public static int gcd(int m, int n) {
while (true) {
if ((m = m % n) == 0)
return n;
if ((n = n % m) == 0)
return m;
}
}
public static void main(String args[]) throws Exception
{
//取得输入值
//Scanner chin = new Scanner(System.in);
//int a = chin.nextInt(), b = chin.nextInt();
int a=23; int b=32;
int c = gcd(a, b);
System.out.println(&quot;最小公倍数：&quot; + a * b / c + &quot;\n最大公约数：&quot; + c);
}
}
</code></pre><h3 id="【正则表达式matches】输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。"><a href="#【正则表达式matches】输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。" class="headerlink" title="【正则表达式matches】输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。"></a>【正则表达式matches】输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。</h3><p>1.程序分析：利用while语句,条件为输入的字符不为 ‘\n ‘. </p>
<pre><code>import java.util.Scanner;
public class ex7 {
     public static void main(String args[])
     {
      System.out.println(&quot;请输入字符串：&quot;);
      Scanner scan=new Scanner(System.in);
      String str=scan.next();
      String E1=&quot;[\u4e00-\u9fa5]&quot;;
      String E2=&quot;[a-zA-Z]&quot;;
      int countH=0;
      int countE=0;
      char[] arrChar=str.toCharArray();
      String[] arrStr=new String[arrChar.length];
      for (int i=0;i&lt;arrChar.length ;i++ )
      {
       arrStr[i]=String.valueOf(arrChar[i]);
      }
      for (String i: arrStr )
      {
       if (i.matches(E1))
       {
        countH++;
       }
       if (i.matches(E2))
       {
        countE++;
       }
      }
      System.out.println(&quot;汉字的个数&quot;+countH);
      System.out.println(&quot;字母的个数&quot;+countE);
     }
    }
</code></pre><h3 id="求s-a-aa-aaa-aaaa-aa…a的值，其中a是一个数字。例如2-22-222-2222-22222-此时共有5个数相加-，几个数相加有键盘控制。"><a href="#求s-a-aa-aaa-aaaa-aa…a的值，其中a是一个数字。例如2-22-222-2222-22222-此时共有5个数相加-，几个数相加有键盘控制。" class="headerlink" title="求s=a+aa+aaa+aaaa+aa…a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加有键盘控制。"></a>求s=a+aa+aaa+aaaa+aa…a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加有键盘控制。</h3><p>1.程序分析：关键是计算出每一项的值。 </p>
<pre><code>import java.io.*;
public class Sumloop {
  public static void main(String[] args) throws IOException
  {
      int s=0;
      String output=&quot;&quot;;
      BufferedReader stadin = new BufferedReader(new InputStreamReader(System.in));
      System.out.println(&quot;请输入a的值&quot;);
      String input =stadin.readLine();
      for(int i =1;i&lt;=Integer.parseInt(input);i++)
      {
          output+=input;
          int a=Integer.parseInt(output);
          s+=a;
      }
      System.out.println(s);
  }
}
另解:
import java.io.*;
public class Sumloop {
  public static void main(String[] args) throws IOException
  {
      int s=0;
      int n;
      int t=0;
      BufferedReader stadin = new BufferedReader(new InputStreamReader(System.in));
      String input = stadin.readLine();
      n=Integer.parseInt(input);
      for(int i=1;i&lt;=n;i++){
       t=t*10+n;
       s=s+t;
       System.out.println(t);
      }
      System.out.println(s);
     }
}
</code></pre><h3 id="一个数如果恰好等于它的因子之和，这个数就称为-“完数-“。例如6-1＋2＋3-编程-找出1000以内的所有完数。"><a href="#一个数如果恰好等于它的因子之和，这个数就称为-“完数-“。例如6-1＋2＋3-编程-找出1000以内的所有完数。" class="headerlink" title="一个数如果恰好等于它的因子之和，这个数就称为 “完数 “。例如6=1＋2＋3.编程   找出1000以内的所有完数。"></a>一个数如果恰好等于它的因子之和，这个数就称为 “完数 “。例如6=1＋2＋3.编程   找出1000以内的所有完数。</h3><pre><code>public class Wanshu {
 public static void main(String[] args)
 {
     int s;
     for(int i=1;i&lt;=1000;i++)
     {
         s=0;
         for(int j=1;j&lt;i;j++)
         //如果余数为0说明 该除数是被除数的因子
             if(i % j==0)
                 s=s+j;
            if(s==i)
                System.out.print(i+&quot; &quot;);
     }
     System.out.println();
 }
}
</code></pre><h3 id="一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在-第10次落地时，共经过多少米？第10次反弹多高？"><a href="#一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在-第10次落地时，共经过多少米？第10次反弹多高？" class="headerlink" title="一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在   第10次落地时，共经过多少米？第10次反弹多高？"></a>一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在   第10次落地时，共经过多少米？第10次反弹多高？</h3><pre><code>public class Ex10 {
 public static void main(String[] args)
 {
     double s=0;
     double t=100;
     for(int i=1;i&lt;=10;i++)
     {
         s+=t;
         t=t/2;
     }
     System.out.println(s);
     System.out.println(t);

 }
}
</code></pre><h3 id="【妙不可言】有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？"><a href="#【妙不可言】有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？" class="headerlink" title="【妙不可言】有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？"></a>【妙不可言】有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？</h3><p>1.程序分析：可填在百位、十位、个位的数字都是1、2、3、4。组成所有的排列后再去   掉不满足条件的排列。</p>
<pre><code>public class Wanshu {
 public static void main(String[] args) {
    int i=0;
    int j=0;
    int k=0;
    int t=0;
    for(i=1;i&lt;=4;i++)
        for(j=1;j&lt;=4;j++)
            for(k=1;k&lt;=4;k++)
                if(i!=j &amp;&amp; j!=k &amp;&amp; i!=k)
                {t+=1;
                    System.out.println(i*100+j*10+k);
 } 
    System.out.println (t);
    }
}
</code></pre><h3 id="企业发放的奖金根据利润提成。利润-I-低于或等于10万元时，奖金可提10-；利润高于10万元，低于20万元时，低于10万元的部分按10-提成，高于10万元的部分，可提成7-5-；20万到40万之间时，高于20万元的部分，可提成5-；40万到60万之间时高于40万元的部分，可提成3-；60万到100万之间时，高于60万元的部分，可提成1-5-，高于100万元时，超过100万元的部分按1-提成，从键盘输入当月利润I，求应发放奖金总数？"><a href="#企业发放的奖金根据利润提成。利润-I-低于或等于10万元时，奖金可提10-；利润高于10万元，低于20万元时，低于10万元的部分按10-提成，高于10万元的部分，可提成7-5-；20万到40万之间时，高于20万元的部分，可提成5-；40万到60万之间时高于40万元的部分，可提成3-；60万到100万之间时，高于60万元的部分，可提成1-5-，高于100万元时，超过100万元的部分按1-提成，从键盘输入当月利润I，求应发放奖金总数？" class="headerlink" title="企业发放的奖金根据利润提成。利润(I)低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万到60万之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%，高于100万元时，超过100万元的部分按1%提成，从键盘输入当月利润I，求应发放奖金总数？"></a>企业发放的奖金根据利润提成。利润(I)低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万到60万之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%，高于100万元时，超过100万元的部分按1%提成，从键盘输入当月利润I，求应发放奖金总数？</h3><p>1.程序分析：请利用数轴来分界，定位。注意定义时需把奖金定义成长整型。 </p>
<pre><code>import java .util.*;
public class test {
    public static void main (String[]args){
        double sum;//声明要储存的变量应发的奖金
        Scanner input =new Scanner (System.in);//导入扫描器
        System.out.print (&quot;输入当月利润&quot;);
        double lirun=input .nextDouble();//从控制台录入利润
        if(lirun&lt;=100000){
            sum=lirun*0.1;
        }else if (lirun&lt;=200000){
            sum=10000+lirun*0.075;
        }else if (lirun&lt;=400000){
            sum=17500+lirun*0.05;
        }else if (lirun&lt;=600000){
            sum=lirun*0.03;
        }else if (lirun&lt;=1000000){
            sum=lirun*0.015;
        } else{
            sum=lirun*0.01;
        }
        System.out.println(&quot;应发的奖金是&quot;+sum);
        }
}
</code></pre><h3 id="一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？"><a href="#一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？" class="headerlink" title="一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？"></a>一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？</h3><p>1.程序分析：在10万以内判断，先将该数加上100后再开方，再将该数加上268后再开方，如果开方后的结果满足如下条件，即是结果。请看具体分析： </p>
<pre><code>public class test {
    public static void main (String[]args){
    long k=0;
    for(k=1;k&lt;=100000l;k++)
        if(Math.floor(Math.sqrt(k+100))==Math.sqrt(k+100) &amp;&amp; Math.floor(Math.sqrt(k+168))==Math.sqrt(k+168))
            System.out.println(k);
    }
}
</code></pre><h3 id="输入某年某月某日，判断这一天是这一年的第几天？"><a href="#输入某年某月某日，判断这一天是这一年的第几天？" class="headerlink" title="输入某年某月某日，判断这一天是这一年的第几天？"></a>输入某年某月某日，判断这一天是这一年的第几天？</h3><p>1.程序分析：以3月5日为例，应该先把前两个月的加起来，然后再加上5天即本年的第几天，特殊情况，闰年且输入月份大于3时需考虑多加一天。 </p>
<pre><code>import java.util.*;
public class test {
    public static void main (String[]args){
        int day=0;
        int month=0;
        int year=0;
        int sum=0;
        int leap;  
        System.out.print(&quot;请输入年,月,日\n&quot;);  
        Scanner input = new Scanner(System.in);
        year=input.nextInt();
        month=input.nextInt();
        day=input.nextInt();
        switch(month) /*先计算某月以前月份的总天数*/ 
        {  
        case 1:
            sum=0;break;  
        case 2:
            sum=31;break;  
        case 3:
            sum=59;break;  
        case 4:
            sum=90;break;  
        case 5:
            sum=120;break;  
        case 6:
            sum=151;break;  
        case 7:
            sum=181;break;  
        case 8:
            sum=212;break;  
        case 9:
            sum=243;break;  
        case 10:
            sum=273;break;  
        case 11:
            sum=304;break;  
        case 12:
            sum=334;break;  
        default:
            System.out.println(&quot;data error&quot;);break;
        }  
        sum=sum+day; /*再加上某天的天数*/ 
        if(year%400==0||(year%4==0&amp;&amp;year%100!=0))/*判断是不是闰年*/ 
            leap=1;  
        else 
            leap=0;  
        if(leap==1 &amp;&amp; month&gt;2)/*如果是闰年且月份大于2,总天数应该加一天*/ 
            sum++;  
        System.out.println(&quot;It is the the day:&quot;+sum);
        }
}
</code></pre><h3 id="输入三个整数x-y-z，请把这三个数由小到大输出。"><a href="#输入三个整数x-y-z，请把这三个数由小到大输出。" class="headerlink" title="输入三个整数x,y,z，请把这三个数由小到大输出。"></a>输入三个整数x,y,z，请把这三个数由小到大输出。</h3><p>1.程序分析：我们想办法把最小的数放到x上，先将x与y进行比较，如果x&gt; y则将x与y的值进行交换，然后再用x与z进行比较，如果x&gt; z则将x与z的值进行交换，这样能使x最小</p>
<pre><code>import java.util.*;
public class test {
    public static void main (String[]args){
        int i=0;
        int j=0;
        int k=0;
        int x=0;
        System.out.print(&quot;请输入三个数\n&quot;);  
        Scanner input = new Scanner(System.in);
        i=input.nextInt();
        j=input.nextInt();
        k=input.nextInt();
        if(i&gt;j)
        {
          x=i;
          i=j;
          j=x;
        }
        if(i&gt;k)
        {
          x=i;
          i=k;
          k=x;
        }
        if(j&gt;k)
        {
          x=j;
          j=k;
          k=x;
        }
        System.out.println(i+&quot;, &quot;+j+&quot;, &quot;+k);
    }
}
</code></pre><h3 id="输出9-9口诀。"><a href="#输出9-9口诀。" class="headerlink" title="输出9*9口诀。"></a>输出9*9口诀。</h3><p>1.程序分析：分行与列考虑，共9行9列，i控制行，j控制列。</p>
<pre><code>public class jiujiu {
public static void main(String[] args)
{
    int i=0;
    int j=0;
    for(i=1;i&lt;=9;i++)
    {   for(j=1;j&lt;=9;j++)
            System.out.print(i+&quot;*&quot;+j+&quot;=&quot;+i*j+&quot;\t&quot;);
            System.out.println();
    }
}
}
不出现重复的乘积(下三角)
public class jiujiu {
public static void main(String[] args)
{
    int i=0;
    int j=0;
    for(i=1;i&lt;=9;i++)
    {   for(j=1;j&lt;=i;j++)
            System.out.print(i+&quot;*&quot;+j+&quot;=&quot;+i*j+&quot;\t&quot;);
            System.out.println();
    }
}
}
上三角
public class jiujiu {
public static void main(String[] args)
{
    int i=0;
    int j=0;
    for(i=1;i&lt;=9;i++)
    {   for(j=i;j&lt;=9;j++)
            System.out.print(i+&quot;*&quot;+j+&quot;=&quot;+i*j+&quot;\t&quot;);
            System.out.println();
    }
}
}
</code></pre><h3 id="猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个-第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下-的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。"><a href="#猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个-第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下-的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。" class="headerlink" title="猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个   第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下   的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。"></a>猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个   第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下   的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。</h3><p>1.程序分析：采取逆向思维的方法，从后往前推断。</p>
<pre><code>public class 猴子吃桃 {
    static int total(int day){
         if(day == 10){
          return 1;
         }
         else{
          return (total(day+1)+1)*2;
         }
        }
public static void main(String[] args)
{
    System.out.println(total(1));
}
}
</code></pre><h3 id="两个乒乓球队进行比赛，各出三人。甲队为a-b-c三人，乙队为x-y-z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x-z比，请编程序找出三队赛手的名单。"><a href="#两个乒乓球队进行比赛，各出三人。甲队为a-b-c三人，乙队为x-y-z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x-z比，请编程序找出三队赛手的名单。" class="headerlink" title="两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x,z比，请编程序找出三队赛手的名单。"></a>两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x,z比，请编程序找出三队赛手的名单。</h3><p>1.程序分析：判断素数的方法：用一个数分别去除2到sqrt(这个数)，如果能被整除，   则表明此数不是素数，反之是素数。</p>
<pre><code>import java.util.ArrayList;
public class pingpang {
     String a,b,c;
     public static void main(String[] args) {
      String[] op = { &quot;x&quot;, &quot;y&quot;, &quot;z&quot; };
      ArrayList&lt;pingpang&gt; arrayList=new ArrayList&lt;pingpang&gt;();
      for (int i = 0; i &lt; 3; i++)
       for (int j = 0; j &lt; 3; j++)
        for (int k = 0; k &lt; 3; k++) {
            pingpang a=new pingpang(op[i],op[j],op[k]);
         if(!a.a.equals(a.b)&amp;&amp;!a.b.equals(a.c)&amp;&amp;!a.a.equals(&quot;x&quot;)
           &amp;&amp;!a.c.equals(&quot;x&quot;)&amp;&amp;!a.c.equals(&quot;z&quot;)){
          arrayList.add(a);
         }
        }
      for(Object a:arrayList){
      System.out.println(a);
      }
     }
     public pingpang(String a, String b, String c) {
      super();
      this.a = a;
      this.b = b;
      this.c = c;
     }
     @Override
     public String toString() {
      // TODO Auto-generated method stub
      return &quot;a的对手是&quot;+a+&quot;,&quot;+&quot;b的对手是&quot;+b+&quot;,&quot;+&quot;c的对手是&quot;+c+&quot;\n&quot;;
     }
}
</code></pre><h3 id="有一分数序列：2-1，3-2，5-3，8-5，13-8，21-13…求出这个数列的前20项之和。"><a href="#有一分数序列：2-1，3-2，5-3，8-5，13-8，21-13…求出这个数列的前20项之和。" class="headerlink" title="有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13…求出这个数列的前20项之和。"></a>有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13…求出这个数列的前20项之和。</h3><p>1.程序分析：请抓住分子与分母的变化规律。</p>
<pre><code>public class test20 {
 public static void main(String[] args) {
  float fm = 1f;
  float fz = 1f;
  float temp;
  float sum = 0f;
  for (int i=0;i&lt;20;i++){
   temp = fm;
   fm = fz;
   fz = fz + temp;
   sum += fz/fm;
   //System.out.println(sum);
  }
  System.out.println(sum);
 }
}
</code></pre><h3 id="求1-2-3-…-20-的和"><a href="#求1-2-3-…-20-的和" class="headerlink" title="求1+2!+3!+…+20!的和"></a>求1+2!+3!+…+20!的和</h3><p>1.程序分析：此程序只是把累加变成了累乘。 </p>
<pre><code>public class Ex21 {
    static long sum = 0;
    static long fac = 0;
    public static void main(String[] args) {
       long sum = 0;
       long fac = 1;
       for(int i=1; i&lt;=10; i++) {
        fac = fac * i;
        sum += fac;
       }
       System.out.println(sum);
    }
    }
</code></pre><h3 id="利用递归方法求5-。"><a href="#利用递归方法求5-。" class="headerlink" title="利用递归方法求5!。"></a>利用递归方法求5!。</h3><p>1.程序分析：递归公式：fn=fn_1*4! </p>
<pre><code>import java.util.Scanner;
public class Ex22 {
public static void main(String[] args) {
   Scanner s = new Scanner(System.in);
   int n = s.nextInt();
   Ex22 tfr = new Ex22();
   System.out.println(tfr.recursion(n));

}

public long recursion(int n) {
   long value = 0 ;
   if(n ==1 || n == 0) {
    value = 1;
   } else if(n &gt; 1) {
    value = n * recursion(n-1);
   }
   return value;
}

}
</code></pre><h3 id="有5个人坐在一起，问第五个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第3个人大2岁。问第三个人，又说比第2人大两岁。问第2个人，说比第一个人大两岁。最后问第一个人，他说是10岁。请问第五个人多大？"><a href="#有5个人坐在一起，问第五个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第3个人大2岁。问第三个人，又说比第2人大两岁。问第2个人，说比第一个人大两岁。最后问第一个人，他说是10岁。请问第五个人多大？" class="headerlink" title="有5个人坐在一起，问第五个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第3个人大2岁。问第三个人，又说比第2人大两岁。问第2个人，说比第一个人大两岁。最后问第一个人，他说是10岁。请问第五个人多大？"></a>有5个人坐在一起，问第五个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第3个人大2岁。问第三个人，又说比第2人大两岁。问第2个人，说比第一个人大两岁。最后问第一个人，他说是10岁。请问第五个人多大？</h3><p>1.程序分析：利用递归的方法，递归分为回推和递推两个阶段。要想知道第五个人岁数，需知道第四人的岁数，依次类推，推到第一人（10岁），再往回推。</p>
<pre><code>public class Ex23 {

     static int getAge(int n){
      if (n==1){
       return 10;
      }
      return 2 + getAge(n-1);
     }
     public static void main(String[] args) {
      System.out.println(&quot;第五个的年龄为:&quot;+getAge(5));
     }
    }
</code></pre><h3 id="给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。"><a href="#给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。" class="headerlink" title="给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。"></a>给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。</h3><pre><code>import java.util.Scanner;
public class Ex24 {
public static void main(String[] args) {
   Ex24 tn = new Ex24();
   Scanner s = new Scanner(System.in);
   long a = s.nextLong();
   if(a &lt; 0 || a &gt; 100000) {
    System.out.println(&quot;Error Input, please run this program Again&quot;);
    System.exit(0);
   }
    if(a &gt;=0 &amp;&amp; a &lt;=9) {
    System.out.println( a + &quot;是一位数&quot;);
    System.out.println(&quot;按逆序输出是&quot; + &#39;\n&#39; + a);
   } else if(a &gt;= 10 &amp;&amp; a &lt;= 99) {
    System.out.println(a + &quot;是二位数&quot;);
    System.out.println(&quot;按逆序输出是&quot; );
    tn.converse(a);
   } else if(a &gt;= 100 &amp;&amp; a &lt;= 999) {
    System.out.println(a + &quot;是三位数&quot;);
    System.out.println(&quot;按逆序输出是&quot; );
    tn.converse(a);
   } else if(a &gt;= 1000 &amp;&amp; a &lt;= 9999) {
    System.out.println(a + &quot;是四位数&quot;);
    System.out.println(&quot;按逆序输出是&quot; );
    tn.converse(a);
   } else if(a &gt;= 10000 &amp;&amp; a &lt;= 99999) {
    System.out.println(a + &quot;是五位数&quot;);
    System.out.println(&quot;按逆序输出是&quot; );
    tn.converse(a);
   }
}
public void converse(long l) {
   String s = Long.toString(l);
   char[] ch = s.toCharArray();
   for(int i=ch.length-1; i&gt;=0; i--) {
    System.out.print(ch[i]);
   }
}
}
</code></pre><h3 id="一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。"><a href="#一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。" class="headerlink" title="一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。"></a>一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。</h3><pre><code>import java.util.Scanner; 
public class Ex25 { 
    static int[] a = new int[5]; 
    static int[] b = new int[5]; 
    public static void main(String[] args) { 
        boolean is =false; 
        Scanner s = new Scanner(System.in); 
        long l = s.nextLong(); 
        if (l &gt; 99999 || l &lt; 10000) { 
            System.out.println(&quot;Input error, please input again!&quot;); 
            l = s.nextLong(); 
        } 
        for (int i = 4; i &gt;= 0; i--) { 
            a[i] = (int) (l / (long) Math.pow(10, i));
            l =(l % ( long) Math.pow(10, i)); 
            System.out.println(); 
        for(int i=0,j=0; i&lt;5; i++, j++) { 
            b[j] = a[i]; 
        } 
        for(int i=0,j=4; i&lt;5; i++, j--) { 
            if(a[i] != b[j]) { 
                is = false; break; 
            } else {
                is = true;
              } 
         } 
        if(is == false) {  
            System.out.println(&quot;is not a Palindrom!&quot;);  
        } else if(is == true) {  
        System.out.println(&quot;is a Palindrom!&quot;);  
          }  
      }  
  }
</code></pre><h3 id="请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续-判断第二个字母。"><a href="#请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续-判断第二个字母。" class="headerlink" title="请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续   判断第二个字母。"></a>请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续   判断第二个字母。</h3><p>1.程序分析：用情况语句比较好，如果第一个字母一样，则判断用情况语句或if语句判断第二个字母。  </p>
<pre><code>import java.util.Scanner;
public class Ex26 {
 public static void main(String[] args){
  //保存用户输入的第二个字母
  char weekSecond;
  //将Scanner类示例化为input对象，用于接收用户输入
  Scanner input = new Scanner(System.in);
  //开始提示并接收用户控制台输入
  System.out.print(&quot;请输入星期值英文的第一个字母，我来帮您判断是星期几：&quot;);
  String letter = input.next();
  //判断用户控制台输入字符串长度是否是一个字母
  if (letter.length() == 1){
   //利用取第一个索引位的字符来实现让Scanner接收char类型输入
   char weekFirst = letter.charAt(0);
   switch (weekFirst){
  case &#39;m&#39;:
     //当输入小写字母时，利用switch结构特性执行下一个带break语句的case分支，以实现忽略用户控制台输入大小写敏感的功能
    case &#39;M&#39;:
      System.out.println(&quot;星期一(Monday)&quot;);
     break;
     case &#39;t&#39;:
     //当输入小写字母时，利用switch结构特性执行下一个带break语句的case分支，以实现忽略用户控制台输入大小写敏感的功能
    case &#39;T&#39;:
      System.out.print(&quot;由于星期二(Tuesday)与星期四(Thursday)均以字母T开头，故需输入第二个字母才能正确判断：&quot;);
     letter = input.next();
     //判断用户控制台输入字符串长度是否是一个字母
     if (letter.length() == 1){
      //利用取第一个索引位的字符来实现让Scanner接收char类型输入
      weekSecond = letter.charAt(0);
      //利用或（||）运算符来实现忽略用户控制台输入大小写敏感的功能
      if (weekSecond == &#39;U&#39; || weekSecond == &#39;u&#39;){
       System.out.println(&quot;星期二(Tuesday)&quot;);
       break;
      //利用或（||）运算符来实现忽略用户控制台输入大小写敏感的功能
      } else if (weekSecond == &#39;H&#39; || weekSecond == &#39;h&#39;){
       System.out.println(&quot;星期四(Thursday)&quot;);
       break;
      //控制台错误提示
      } else{
       System.out.println(&quot;输入错误，不能识别的星期值第二个字母，程序结束！&quot;);
       break;
      }
     } else {
      //控制台错误提示
      System.out.println(&quot;输入错误，只能输入一个字母，程序结束！&quot;);
      break;
     }
    case &#39;w&#39;:
     //当输入小写字母时，利用switch结构特性执行下一个带break语句的case分支，以实现忽略用户控制台输入大小写敏感的功能
    case &#39;W&#39;:
     System.out.println(&quot;星期三(Wednesday)&quot;);
     break;
    case &#39;f&#39;:
     //当输入小写字母时，利用switch结构特性执行下一个带break语句的case分支，以实现忽略用户控制台输入大小写敏感的功能
    case &#39;F&#39;:
     System.out.println(&quot;星期五(Friday)&quot;);
     break;
    case &#39;s&#39;:
     //当输入小写字母时，利用switch结构特性执行下一个带break语句的case分支，以实现忽略用户控制台输入大小写敏感的功能
    case &#39;S&#39;:
     System.out.print(&quot;由于星期六(Saturday)与星期日(Sunday)均以字母S开头，故需输入第二个字母才能正确判断：&quot;);
     letter = input.next();
     //判断用户控制台输入字符串长度是否是一个字母
     if (letter.length() == 1){
      //利用取第一个索引位的字符来实现让Scanner接收char类型输入
      weekSecond = letter.charAt(0);
      //利用或（||）运算符来实现忽略用户控制台输入大小写敏感的功能
      if (weekSecond == &#39;A&#39; || weekSecond == &#39;a&#39;){
       System.out.println(&quot;星期六(Saturday)&quot;);
       break;
      //利用或（||）运算符来实现忽略用户控制台输入大小写敏感的功能
      } else if (weekSecond == &#39;U&#39; || weekSecond == &#39;u&#39;){
       System.out.println(&quot;星期日(Sunday)&quot;);
       break;
      //控制台错误提示
      } else{
       System.out.println(&quot;输入错误，不能识别的星期值第二个字母，程序结束！&quot;);
       break;
      }
     } else{
      //控制台错误提示
      System.out.println(&quot;输入错误，只能输入一个字母，程序结束！&quot;);
      break;
     }
    default:
     //控制台错误提示
     System.out.println(&quot;输入错误，不能识别的星期值第一个字母，程序结束！&quot;);
     break;
   }
  } else{
   //控制台错误提示
   System.out.println(&quot;输入错误，只能输入一个字母，程序结束！&quot;);
  }
 }
}
</code></pre><h3 id="打印出如下图案（菱形）"><a href="#打印出如下图案（菱形）" class="headerlink" title="打印出如下图案（菱形）"></a>打印出如下图案（菱形）</h3><p>_*   </p>
<p>_***   </p>
<p>_<strong>**</strong>   </p>
<p>_<strong><em>**</em></strong>   </p>
<p>_<strong>**</strong>   </p>
<p>_***   </p>
<p>_*   </p>
<p>1.程序分析：先把图形分成两部分来看待，前四行一个规律，后三行一个规律，利用双重   for循环，第一层控制行，第二层控制列。 </p>
<pre><code>三角形：
public class StartG {
   public static void main(String [] args)
   {
       int i=0;
       int j=0;
       for(i=1;i&lt;=4;i++)
       {   for(j=1;j&lt;=2*i-1;j++)
               System.out.print(&quot;*&quot;);
            System.out.println(&quot;&quot;);   
       }
       for(i=4;i&gt;=1;i--)
       { for(j=1;j&lt;=2*i-3;j++)
               System.out.print(&quot;*&quot;);
                System.out.println(&quot;&quot;);   
       }
   }
 }

菱形：
public class StartG {
   public static void main(String [] args)
   {
       int i=0;
       int j=0;
       for(i=1;i&lt;=4;i++)
       {
           for(int k=1; k&lt;=4-i;k++)
             System.out.print(&quot; &quot;);
           for(j=1;j&lt;=2*i-1;j++)
               System.out.print(&quot;*&quot;);
           System.out.println(&quot;&quot;);   
       }
       for(i=4;i&gt;=1;i--)
       {
           for(int k=1; k&lt;=5-i;k++)
                 System.out.print(&quot; &quot;);
           for(j=1;j&lt;=2*i-3;j++)
               System.out.print(&quot;*&quot;);
            System.out.println(&quot;&quot;);   
       }
   }
 }
</code></pre><h3 id="题目：打印出杨辉三角形（要求打印出10行如下图）"><a href="#题目：打印出杨辉三角形（要求打印出10行如下图）" class="headerlink" title="题目：打印出杨辉三角形（要求打印出10行如下图）"></a>题目：打印出杨辉三角形（要求打印出10行如下图）</h3><p>1.程序分析：  </p>
<p>1  </p>
<p>1   1  </p>
<p>1   2   1  </p>
<p>1   3   3   1  </p>
<p>1   4   6   4   1  </p>
<p>1   5   10   10   5   1  </p>
<pre><code>public class Ex33 {
    public static void main(String args[]){
           int i,j;
           int a[][];
           a=new int[8][8];
          for(i=0;i&lt;8;i++){
             a[i][i]=1;
             a[i][0]=1;
            }
          for(i=2;i&lt;8;i++){
           for(j=1;j&lt;=i-1;j++){
          a[i][j]=a[i-1][j-1]+a[i-1][j];
           }
          } 
          for(i=0;i&lt;8;i++){
          for(j=0;j&lt;i;j++){ 
           System.out.printf(&quot;  &quot;+a[i][j]);
           }
          System.out.println();
          }
         }
}
</code></pre><h3 id="求100之内的素数"><a href="#求100之内的素数" class="headerlink" title="求100之内的素数"></a>求100之内的素数</h3><pre><code>public class Ex27 {
 public static void main(String args[])
 {
  int sum,i;
  for(sum=2;sum&lt;=100;sum++)
  {
   for(i=2;i&lt;=sum/2;i++)
   {
    if(sum%i==0)
     break;
   }
   if(i&gt;sum/2)
    System.out.println(sum+&quot;是素数&quot;);
  }
 }
}
</code></pre><h3 id="输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组"><a href="#输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组" class="headerlink" title="输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组"></a>输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组</h3><pre><code>import java.util.*;
public class Ex35 {
public static void main(String[] args) {
int i, min, max, n, temp1, temp2;
int a[];
System.out.println(&quot;输入数组的长度:&quot;);
Scanner keyboard = new Scanner(System.in);
n = keyboard.nextInt();
a = new int[n];
for (i = 0; i &lt; n; i++) {
System.out.print(&quot;输入第&quot; + (i + 1) + &quot;个数据&quot;);
a[i] = keyboard.nextInt();
}
//以上是输入整个数组
max = 0;
min = 0;
//设置两个标志,开始都指向第一个数
for (i = 1; i &lt; n; i++) {
if (a[i] &gt; a[max])
max = i; //遍历数组,如果大于a[max]，就把他的数组下标赋给max
if (a[i] &lt; a[min])
min = i; //同上，如果小于a[min],就把他的数组下标赋给min
}
//以上for循环找到最大值和最小值，max是最大值的下标，min是最小值的下标
temp1 = a[0];
temp2 = a[min]; //这两个temp只是为了在交换时使用

a[0] = a[max];
a[max] = temp1; //首先交换a[0]和最大值a[max]

if (min != 0) { //如果最小值不是a[0]，执行下面
a[min] = a[n - 1];
a[n - 1] = temp2; //交换a[min]和a[n-1]
} else {       //如果最小值是a[0],执行下面
a[max] = a[n - 1];
a[n - 1] = temp1;
}

for (i = 0; i &lt; n; i++) { //输出数组
System.out.print(a[i] + &quot; &quot;);
}
}
}
</code></pre><h3 id="海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子凭据分为五份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的，问海滩上原来最少有多少个桃子？"><a href="#海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子凭据分为五份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的，问海滩上原来最少有多少个桃子？" class="headerlink" title="海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子凭据分为五份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的，问海滩上原来最少有多少个桃子？"></a>海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子凭据分为五份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的，问海滩上原来最少有多少个桃子？</h3><pre><code>public class Dg {
static int ts=0;//桃子总数
int fs=1;//记录分的次数
static int hs=5;//猴子数...
int tsscope=5000;//桃子数的取值范围.太大容易溢出.
public int fT(int t){
if(t==tsscope){
//当桃子数到了最大的取值范围时取消递归
System.out.println(&quot;结束&quot;);
return 0;
}
else{
if((t-1)%hs==0 &amp;&amp; fs &lt;=hs){
if(fs==hs)
{
System.out.println(&quot;桃子数 = &quot;+ts +&quot; 时满足分桃条件&quot;);
}
   fs+=1;
   return fT((t-1)/5*4);// 返回猴子拿走一份后的剩下的总数
}
else
{
//没满足条件
fs=1;//分的次数重置为1
return fT(ts+=1);//桃子数加+1
}
}
}
public static void main(String[] args) {
new Dg().fT(0);
}

}
</code></pre><h3 id="输入3个数a-b-c，按大小顺序输出。"><a href="#输入3个数a-b-c，按大小顺序输出。" class="headerlink" title="输入3个数a,b,c，按大小顺序输出。"></a>输入3个数a,b,c，按大小顺序输出。</h3><p>1.程序分析：利用指针方法。</p>
<pre><code>public class Ex34 {
    public static void main(String[] args)
    {
    int []arrays = {800,56,500};
    for(int i=arrays.length;--i&gt;=0;)
    {
    for(int j=0;j&lt;i;j++)
    {
    if(arrays[j]&gt;arrays[j+1])
    {
    int temp=arrays[j];
    arrays[j]=arrays[j+1];
    arrays[j+1]=temp;
    }
    }
    }
    for(int n=0;n&lt;arrays.length;n++)
    System.out.println(arrays[n]);
    }

}
</code></pre><h3 id="有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位"><a href="#有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位" class="headerlink" title="有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位"></a>有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位</h3><pre><code>import java.util.Scanner;
public class Ex37 {
    public static void main(String[] args) {
           Scanner s = new Scanner(System.in);
           int n = s.nextInt();
           boolean[] arr = new boolean[n];
           for(int i=0; i&lt;arr.length; i++) {
            arr[i] = true;//下标为TRUE时说明还在圈里
           }
           int leftCount = n;
           int countNum = 0;
           int index = 0;
           while(leftCount &gt; 1) {
            if(arr[index] == true) {//当在圈里时
             countNum ++; //报数递加
             if(countNum == 3) {//报道3时
              countNum =0;//从零开始继续报数
              arr[index] = false;//此人退出圈子
              leftCount --;//剩余人数减一
             }
            }
            index ++;//每报一次数，下标加一
            if(index == n) {//是循环数数，当下标大于n时，说明已经数了一圈，
             index = 0;//将下标设为零重新开始。
            }
           }
           for(int i=0; i&lt;n; i++) {
            if(arr[i] == true) {
             System.out.println(i);
            }
           }
     }
}
</code></pre><h3 id="写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度"><a href="#写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度" class="headerlink" title="写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度"></a>写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度</h3><pre><code>import java.util.Scanner;
public class Ex38 {
public static void main(String [] args)
{
    Scanner s = new Scanner(System.in);
    System.out.println(&quot;请输入一个字符串&quot;);
    String mys= s.next();
    System.out.println(str_len(mys));
}
  public static int str_len(String x)
  {
      return x.length();
  }
}
</code></pre><h3 id="取一个整数a从右端开始的4～7位。"><a href="#取一个整数a从右端开始的4～7位。" class="headerlink" title="取一个整数a从右端开始的4～7位。"></a>取一个整数a从右端开始的4～7位。</h3><p>程序分析：可以这样考虑：<br>(1)先使a右移4位。<br>(2)设置一个低4位全为1,其余全为0的数。可用~(~0 &lt; &lt;4)<br>(3)将上面二者进行&amp;运算。  </p>
<pre><code>import java.util.Random;
public class ArraySort {
  public static void main(String[] args)
  {  int temp=0;
      int myarr[] = new int[12];
      Random r=new Random();
      for(int i=1;i&lt;=10;i++)
        myarr[i]=r.nextInt(1000);
      for (int k=1;k&lt;=10;k++)
      System.out.print(myarr[k]+&quot;,&quot;);
      for(int i=1;i&lt;=9;i++)
          for(int k=i+1;k&lt;=10;k++)
              if(myarr[i]&gt;myarr[k])
              {
                  temp=myarr[i];
                  myarr[i]=myarr[k];
                  myarr[k]=temp;
              }
      System.out.println(&quot;&quot;);
      for (int k=1;k&lt;=10;k++)
          System.out.print(myarr[k]+&quot;,&quot;);

       myarr[11]=r.nextInt(1000);
       for(int k=1;k&lt;=10;k++)
           if(myarr[k]&gt;myarr[11])
           {
               temp=myarr[11];
               for(int j=11;j&gt;=k+1;j--)
                   myarr[j]=myarr[j-1];
               myarr[k]=temp;
           }
         System.out.println(&quot;&quot;);  
       for (int k=1;k&lt;=11;k++)
              System.out.print(myarr[k]+&quot;,&quot;);
  }
}
</code></pre><h3 id="对10个数进行排序"><a href="#对10个数进行排序" class="headerlink" title="对10个数进行排序"></a>对10个数进行排序</h3><p>1.程序分析：可以利用选择法，即从后9个比较过程中，选择一个最小的与第一个元素交换，<br>依次类推，即用第二个元素与后8个进行比较，并进行交换。  </p>
<pre><code>import java.util.Arrays;
import java.util.Random;
import java.util.Scanner;
public class Ex28 {
 public static void main(String[] args) {
  int arr[] = new int[11];
  Random r=new Random();
  for(int i=0;i&lt;10;i++){
   arr[i]=r.nextInt(100)+1;//得到10个100以内的整数
  }
  Arrays.sort(arr);
  for(int i=0;i&lt;arr.length;i++){
   System.out.print(arr[i]+&quot;\t&quot;);
  }
  System.out.print(&quot;\nPlease Input a int number: &quot;);
  Scanner sc=new Scanner(System.in);
  arr[10]=sc.nextInt();//输入一个int值
  Arrays.sort(arr);
  for(int i=0;i&lt;arr.length;i++){
   System.out.print(arr[i]+&quot;\t&quot;);
  }
 }
}
</code></pre><h3 id="有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。"><a href="#有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。" class="headerlink" title="有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。"></a>有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。</h3><ol>
<li>程序分析：首先判断此数是否大于最后一个数，然后再考虑插入中间的数的情况，<br>插入后此元素之后的数，依次后移一个位置。   </li>
</ol>
<pre><code>import java.util.Random;
public class ArraySort {
  public static void main(String[] args)
  {  int temp=0;
      int myarr[] = new int[12];
      Random r=new Random();
      for(int i=1;i&lt;=10;i++)
        myarr[i]=r.nextInt(1000);
      for (int k=1;k&lt;=10;k++)
      System.out.print(myarr[k]+&quot;,&quot;);
      for(int i=1;i&lt;=9;i++)
          for(int k=i+1;k&lt;=10;k++)
              if(myarr[i]&gt;myarr[k])
              {
                  temp=myarr[i];
                  myarr[i]=myarr[k];
                  myarr[k]=temp;
              }
      System.out.println(&quot;&quot;);
      for (int k=1;k&lt;=10;k++)
          System.out.print(myarr[k]+&quot;,&quot;);

       myarr[11]=r.nextInt(1000);
       for(int k=1;k&lt;=10;k++)
           if(myarr[k]&gt;myarr[11])
           {
               temp=myarr[11];
               for(int j=11;j&gt;=k+1;j--)
                   myarr[j]=myarr[j-1];
               myarr[k]=temp;
           }
         System.out.println(&quot;&quot;);  
       for (int k=1;k&lt;=11;k++)
              System.out.print(myarr[k]+&quot;,&quot;);
  }
}
</code></pre><h3 id="列出目录下的所有的目录和文件"><a href="#列出目录下的所有的目录和文件" class="headerlink" title="列出目录下的所有的目录和文件"></a><strong>列出目录下的所有的目录和文件</strong></h3><pre><code>import java.io.File;
public class Test {
    public static void main(String[] args) {
        File file = new File(&quot;C:\\testDir&quot;);
        //判断目录是否存在
        if(!file.exists()) {
            System.out.println(&quot;dirctory is empty&quot;);
            return;
        }
        File[] fileList = file.listFiles();
        for(int i = 0;i&lt;fileList.length;i++) {
            if(fileList[i].isDirectory()) {
                System.out.println(&quot;dirctory is:&quot;+fileList[i].getName());
            }else {
                System.out.println(&quot;file is:&quot;+fileList[i].getName());
            }
        }
    }
}
</code></pre><h3 id="获得回文字符串"><a href="#获得回文字符串" class="headerlink" title="获得回文字符串"></a><strong>获得回文字符串</strong></h3><h3 id="去除字符串的n个字符得到回文字符串-返回n"><a href="#去除字符串的n个字符得到回文字符串-返回n" class="headerlink" title="去除字符串的n个字符得到回文字符串 返回n"></a>去除字符串的n个字符得到回文字符串 返回n</h3><pre><code>/*
 * 用动态规划 先反转字符串，从（1，1）开始赋值同位比较相等则=左上角+1 不等则=左侧和上方中的较大值
 * */
import java.util.*;
public class demo0920 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {
            String s1 = sc.next();
            String s2 = new StringBuilder(s1).reverse().toString();
            int[][] dp = new int[s1.length() + 1][s2.length() + 1];
            for (int i = 1; i &lt; dp.length; i ++ ) {
                for (int j = 1; j &lt; dp[0].length; j ++ ) {
                    dp[i][j] = s1.charAt(i - 1) == s2.charAt(j - 1) ? dp[i - 1][j - 1] + 1 : Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
            System.out.println(s1.length() - dp[s1.length()][s2.length()]);
        }
    }
}
</code></pre><p><img src="https://github.com/54321decba/tu/blob/master/2018-09-20/2018092001.png?raw=true" alt="">  </p>
<h3 id="将字符串中的大写字符放到最后"><a href="#将字符串中的大写字符放到最后" class="headerlink" title="将字符串中的大写字符放到最后"></a><strong>将字符串中的大写字符放到最后</strong></h3><pre><code>import java.util.*;
public class demo092001{
    public static void main(String[] args){
        Scanner scan = new Scanner(System.in);
        while(scan.hasNext()){
            String str = scan.nextLine();
            System.out.println(getResult(str));
        }
    }
    public static String getResult(String str){
        //Aaaa 把大写的去除 变成 aaa 把小写的去除变成A 两者拼接aaaA
        return str.replaceAll(&quot;[A-Z]&quot;,&quot;&quot;)+str.replaceAll(&quot;[a-z]&quot;,&quot;&quot;);
    }

}
</code></pre><h3 id="奇偶倒推"><a href="#奇偶倒推" class="headerlink" title="奇偶倒推"></a><strong>奇偶倒推</strong></h3><p>有两台魔法机器可以通过投入x(x可以为0)个魔法币产生更多的魔法币。<br>魔法机器1:如果投入x个魔法币,魔法机器会将其变为2x+1个魔法币<br>魔法机器2:如果投入x个魔法币,魔法机器会将其变为2x+2个魔法币<br>采购魔法神器总共需要n个魔法币,所以只能通过两台魔法机器产生恰好n个魔法币,<br>设计一个投入方案最后恰好拥有n个魔法币。</p>
<p>2台机器1台只能产生奇数，1台只能产生偶数<br>可以通过判断结果是奇数还是偶数倒推上一次的结果，再倒推至0即可退出<br>使用StringBuiler一来大量字符串拼接效率更高，另一方面倒推的操作输出需要反向，sb有reverse可以直接调用</p>
<pre><code>import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        while (in.hasNext()) {
            int coinCount = in.nextInt();
            StringBuilder sb = new StringBuilder();
            while (coinCount &gt; 0) {
                if (coinCount % 2 == 0) {
                    //偶数
                    coinCount = (coinCount - 2) / 2;
                    sb.append(&quot;2&quot;);
                } else {
                    //奇数
                    coinCount = (coinCount - 1) / 2;
                    sb.append(&quot;1&quot;);
                }
            }
            System.out.println(sb.reverse().toString());
        }
    }
}
</code></pre><h3 id="三角"><a href="#三角" class="headerlink" title="三角"></a><strong>三角</strong></h3><pre><code>public class demo0919 {
    public static void main(String[] args) {
        for(int y=0;y&lt;4;y++){
            for(int x=0;x&lt;4;x++){
                if(x&gt;y){
                    System.out.print(&quot; &quot;);
                }else{
                    System.out.print(&quot;1&quot;);
                }

            }
            System.out.println();
        }
        System.out.println(&quot;---------------------------------&quot;);
        for(int y=0;y&lt;4;y++){
            for(int x=0;x&lt;4;x++){
                if(x&lt;3-y){
                    System.out.print(&quot; &quot;);
                }else{
                    System.out.print(&quot;1&quot;);
                }

            }
            System.out.println();
        }
        System.out.println(&quot;---------------------------------&quot;);
        for(int y=0;y&lt;4;y++){
            for(int x=0;x&lt;4;x++){
                if(x&lt;y){
                    System.out.print(&quot; &quot;);
                }else{
                    System.out.print(&quot;1&quot;);
                }

            }
            System.out.println();
        }
        System.out.println(&quot;---------------------------------&quot;);
        for(int y=0;y&lt;4;y++){
            for(int x=0;x&lt;4;x++){
                if(x&gt;3-y){
                    System.out.print(&quot; &quot;);
                }else{
                    System.out.print(&quot;1&quot;);
                }

            }
            System.out.println();
        }
        System.out.println(&quot;---------------------------------&quot;);
        for(int y=0;y&lt;4;y++){
            for(int x=0;x&lt;7;x++){
                if(x&lt;3-y||x&gt;3+y){
                    System.out.print(&quot; &quot;);
                }else{
                    System.out.print(&quot;1&quot;);
                }

            }
            System.out.println();
        }
        System.out.println(&quot;---------------------------------&quot;);
        for(int y=0;y&lt;4;y++){
            for(int x=0;x&lt;7;x++){
                if(x&lt;y||x&gt;6-y){
                    System.out.print(&quot; &quot;);
                }else{
                    System.out.print(&quot;1&quot;);
                }

            }
            System.out.println();
        }
        System.out.println(&quot;---------------------------------&quot;);
    }
}


</code></pre><p><img src="https://github.com/54321decba/tu/blob/master/2018-09-21/三角形.png?raw=true" alt="enter description here"><br>第一象限 x&gt;y<br>第二象限 x&lt;3-y 内层-1<br>第三象限 x<y 第四象限="" x="">3-y 内层-1<br>左右(上) x&lt;3-y||x&gt;3+y 内层-1<br>左右(下) x&lt;y||x&gt;6-y 外层-1</y></p>
<h3 id="StringBuiler的字符串反转"><a href="#StringBuiler的字符串反转" class="headerlink" title="StringBuiler的字符串反转"></a><strong>StringBuiler的字符串反转</strong></h3><p>为了得到一个数的”相反数”,我们将这个数的数字顺序颠倒,然后再加上原先的数得到”相反数”。例如,为了得到1325的”相反数”,首先我们将该数的数字顺序颠倒,我们得到5231,之后再加上原先的数,我们得到5231+1325=6556.如果颠倒之后的数字有前缀零,前缀零将会被忽略。例如n = 100, 颠倒之后是1.</p>
<pre><code>import java.util.Scanner;
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.next();
        System.out.println(Integer.parseInt(new StringBuilder(s).reverse().toString())+Integer.parseInt(s));
        sc.close();
    }
}
</code></pre><h3 id="字符串碎片的平均长度"><a href="#字符串碎片的平均长度" class="headerlink" title="字符串碎片的平均长度"></a><strong>字符串碎片的平均长度</strong></h3><p>一个由小写字母组成的字符串可以看成一些同一字母的最大碎片组成的。例如,”aaabbaaac”是由下面碎片组成的:’aaa’,’bb’,’c’。牛牛现在给定一个字符串,请你帮助计算这个字符串的所有碎片的平均长度是多少。</p>
<pre><code>public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    while (sc.hasNext()) {
        String s = sc.next();
        float len = s.length();//总长
        int count = 1;//个数至少为一个
        for (int i = 0; i &lt; len - 1; i++) {
            if (s.charAt(i) != s.charAt(i + 1)) {
                count++;
            }
        }
        System.out.println(len / count);
    }
}
</code></pre><h3 id="兔子的规律为数列1-1-2-3-5-8-13-21…"><a href="#兔子的规律为数列1-1-2-3-5-8-13-21…" class="headerlink" title="兔子的规律为数列1,1,2,3,5,8,13,21…."></a>兔子的规律为数列1,1,2,3,5,8,13,21….</h3><pre><code>        if(x==1 || x==2)
            return 1;
        else
            return f(x-1)+f(x-2);
</code></pre><h3 id="水仙花数"><a href="#水仙花数" class="headerlink" title="水仙花数"></a>水仙花数</h3><pre><code>       int i=0,j=0,k=0;
       i=x / 100;
       j=(x % 100) /10;
       k=x % 10;
       if(x==i*i*i+j*j*j+k*k*k)
          return true;
       else
          return false;
</code></pre><h3 id="学习成绩-gt-90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示"><a href="#学习成绩-gt-90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示" class="headerlink" title="学习成绩&gt; =90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示"></a>学习成绩&gt; =90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示</h3><p>str=(N&gt;90?”A”:(N&gt;60?”B”:”C”));</p>
<h3 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h3><pre><code>    static int commonDivisor(int M, int N)
    {
        if(N&lt;0||M&lt;0)
        {
            System.out.println(&quot;ERROR!&quot;);
            return -1;
        }
        if(N==0)
        {
            return M;
        }
        return commonDivisor(N,M%N);
    }
</code></pre><p>辗转相除法原理：用较大的除以较小的 用较小的去除以余数</p>
<p><img src="https://github.com/54321decba/tu/blob/master/2018-09-27/2018092701.png?raw=true" alt="enter description here"></p>
<pre><code>public static int gcd(int m, int n) {
while (true) {
if ((m = m % n) == 0)
return n;
if ((n = n % m) == 0)
return m;
}
}
</code></pre><p>最小公倍数=( m*n)/最大公约数</p>
<h3 id="求s-a-aa-aaa-aaaa-aa…a的值，其中a是一个数字。例如2-22-222-2222-22222-此时共有5个数相加-，几个数相加有键盘控制"><a href="#求s-a-aa-aaa-aaaa-aa…a的值，其中a是一个数字。例如2-22-222-2222-22222-此时共有5个数相加-，几个数相加有键盘控制" class="headerlink" title="求s=a+aa+aaa+aaaa+aa…a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加有键盘控制"></a>求s=a+aa+aaa+aaaa+aa…a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，几个数相加有键盘控制</h3><pre><code>      int s=0;
      String output=&quot;&quot;;
      BufferedReader stadin = new BufferedReader(new InputStreamReader(System.in));
      System.out.println(&quot;请输入a的值&quot;);
      String input =stadin.readLine();
      for(int i =1;i&lt;=Integer.parseInt(input);i++)
      {
          output+=input;
          int a=Integer.parseInt(output);
          s+=a;
      }
</code></pre><h3 id="有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？"><a href="#有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？" class="headerlink" title="有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？"></a>有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？</h3><pre><code>public static void main(String[] args) {
    int i=0;
    int j=0;
    int k=0;
    int t=0;
    for(i=1;i&lt;=4;i++)
        for(j=1;j&lt;=4;j++)
            for(k=1;k&lt;=4;k++)
                if(i!=j &amp;&amp; j!=k &amp;&amp; i!=k)
                {t+=1;
                    System.out.println(i*100+j*10+k);
 } 
    System.out.println (t);
    }
</code></pre><h3 id="输入某年某月某日，判断这一天是这一年的第几天？-1"><a href="#输入某年某月某日，判断这一天是这一年的第几天？-1" class="headerlink" title="输入某年某月某日，判断这一天是这一年的第几天？"></a>输入某年某月某日，判断这一天是这一年的第几天？</h3><p>if(year%400==0||(year%4==0&amp;&amp;year%100!=0))/<em>判断是不是闰年</em>/</p>
<h3 id="九九乘法"><a href="#九九乘法" class="headerlink" title="九九乘法"></a>九九乘法</h3><pre><code>int i=0;
    int j=0;
    for(i=1;i&lt;=9;i++)
    {   for(j=1;j&lt;=i;j++)
            System.out.print(j+&quot;*&quot;+i+&quot;=&quot;+i*j+&quot;\t&quot;);
            System.out.println();
    }
</code></pre><h3 id="用递归实现阶乘"><a href="#用递归实现阶乘" class="headerlink" title="用递归实现阶乘"></a>用递归实现阶乘</h3><pre><code>public static long fac(int n){
        if(n&lt;=0) return 0;
        else if(n==1)    return 1;
        else return n*fac(n-1);
    }
    public static void main(String [] args) {
        System.out.println(fac(6));
    }
</code></pre><h3 id="编写一个程序，有1，2-3-4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？"><a href="#编写一个程序，有1，2-3-4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？" class="headerlink" title="编写一个程序，有1，2,3,4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？"></a>编写一个程序，有1，2,3,4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？</h3><pre><code>public class T {
    public static void main(String [] args) {
           int i, j, k;
           int m=0;
           for(i=1;i&lt;=4;i++)
              for(j=1;j&lt;=4;j++)
                for(k=1;k&lt;=4;k++){
                   if(i!=j&amp;&amp;k!=j&amp;&amp;i!=k){
                     //双引号的作用是把打印的内容当做字符串输出 后面加的数字都自动转为字符串  
                     System.out.println(&quot;&quot;+i+j+k);
                     m++;
                   }
                }
            System.out.println(&quot;能组成：&quot;+m+&quot;个&quot;);
    }
}
</code></pre><h3 id="639172每个位数上的数字都是不同的，且平方后所得数字的所有位数都不会出现组成它自身的数字。（639172-639172-408540845584），类似于639172这样的6位数还有几个？分别是什么？"><a href="#639172每个位数上的数字都是不同的，且平方后所得数字的所有位数都不会出现组成它自身的数字。（639172-639172-408540845584），类似于639172这样的6位数还有几个？分别是什么？" class="headerlink" title="639172每个位数上的数字都是不同的，且平方后所得数字的所有位数都不会出现组成它自身的数字。（639172*639172=408540845584），类似于639172这样的6位数还有几个？分别是什么？"></a>639172每个位数上的数字都是不同的，且平方后所得数字的所有位数都不会出现组成它自身的数字。（639172*639172=408540845584），类似于639172这样的6位数还有几个？分别是什么？</h3><pre><code>public void selectNum(){  
        for(long n = 100000; n &lt;= 999999;n++){   
            if(isSelfRepeat(n))                    //有相同的数字，则跳过
                continue;   
            else if(isPingFangRepeat(n*n,n)){    //该数的平方中是否有与该数相同的数字
                continue;   
            }
            else{                                //符合条件，则打印
                   System.out.println(n); 
            }   
        } 
     }

    public boolean isSelfRepeat(long n){
        HashMap&lt;Long,String&gt; m=new HashMap&lt;Long,String&gt;();
        //存储的时候判断有无重复值 每次取最后一位数判断是否已重复 没有则放入hashmap
//再利用/去掉最后一位数 再重新对新的最后一位数进行判断
        while(n!=0){
            if(m.containsKey(n%10)){
                return true;
            }
            else{
                m.put(n%10,&quot;1&quot;);
            }
            n=n/10;
        }
        return false;
    }

    public boolean isPingFangRepeat(long pingfang,long n){
        HashMap&lt;Long,String&gt; m=new HashMap&lt;Long,String&gt;();
        while(n!=0){
            m.put(n%10,&quot;1&quot;);
            n=n/10;
        }

        while(pingfang!=0){
            if(m.containsKey(pingfang%10)){
                return true;
            }
            pingfang=pingfang/10;
        }
        return false;
    }

    public static void main(String args[]){
        new test().selectNum();
    }
</code></pre><p><img src="https://github.com/54321decba/tu/blob/master/2018-09-27/2018092702.png?raw=true" alt="enter description here"></p>
<pre><code>public class testClockwiseOutput { 
    //顺时针打印一个矩阵 

    @Test 
public void test(){ 
//初始化矩阵
        int[][] num = new int[100][100]; 
        int n = 4; 
        int count =1; 

        for(int i=0;i&lt;n;i++){ 
            for(int j =0;j&lt;n;j++){ 
                num[i][j]=count++; 
            } 
        } 

        output(num,0,n-1); 
    } 
    //使用递归每次递归输出一圈
    public void output(int[][] num,int start,int end){ 
        if(start&gt;=end || end&lt;=0)return; 
        //输出上面的一行
        for(int i=start;i&lt;=end;i++){ 
            System.out.println(num[start][i]); 
        } 
        //输出右侧一列
        for(int i=start+1;i&lt;=end;i++){ 
            System.out.println(num[i][end]); 
        } 
         //输出下面一行
 for(int i=end-1;i&gt;=start;i--){ 
            System.out.println(num[end][i]); 
        } 
        //输出左侧一列
for(int i=end-1;i&gt;start;i--){ 
            System.out.println(num[i][start]); 
        } 
        //递归重复操作
        output(num,start+1,end-1); 
    } 
}
</code></pre><h3 id="给出一个排序好的数组和一个数，求数组中连续元素的和等于所给数-并输出该子数组"><a href="#给出一个排序好的数组和一个数，求数组中连续元素的和等于所给数-并输出该子数组" class="headerlink" title="给出一个排序好的数组和一个数，求数组中连续元素的和等于所给数 并输出该子数组"></a>给出一个排序好的数组和一个数，求数组中连续元素的和等于所给数 并输出该子数组</h3><pre><code>@Test 
public void test(){ 
//初始化
        int[] num = {1,2,2,3,4,5,6,7,8,9}; 
        int sum = 7; 
        findSum(num,sum); 
    } 

    public void findSum(int[] num,int sum){ 
        int left=0; 
        int right=0; 
        for(int i=0;i&lt;num.length;i++){ 
            int curSum = 0; 
            left = i; 
            right = i; 
            //把当前数组从左开始累加至大于给定的数即停止
while(curSum&lt;sum){ 
                curSum += num[right++]; 
            }
            //停止后判断是否与给定数相等 不等则继续循环从左侧第2个数开始累加
            if(curSum==sum){ 
                for(int j=left;j&lt;right;j++){ 
                    System.out.print(num[j]+&quot; &quot;); 
                } 
                System.out.println(); 
            } 
        } 
    }
</code></pre><h3 id="用二分法查找已排序好的字母中的随机一个字母的下标"><a href="#用二分法查找已排序好的字母中的随机一个字母的下标" class="headerlink" title="用二分法查找已排序好的字母中的随机一个字母的下标"></a>用二分法查找已排序好的字母中的随机一个字母的下标</h3><pre><code>public class Test5{
    public static int binarySearch(char[] b,char c){
        int min=0,max=b.length-1,mid=0;
        while(min&lt;=max){
         mid=(max+min)/2;
            if(c&lt;b[mid])
                max=mid-1;
            else if(c&gt;b[mid]){
                min=mid+1;
            System.out.println(&quot;hello&quot;);}
            else
                break;
                                    }
        return mid;
    }
    public static void main(String[] args) {
        char[] a={&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;};
        System.out.println(&quot;g在数组中的下标是&quot;+binarySearch(a,&#39;g&#39;));
    }
}
</code></pre><h3 id="编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串，但要保证汉字不被截取半个，-如“我ABC”，4，应该截取“我AB”，输入“我ABC汉DEF”，6，应该输出“我ABC”，而不是“我ABC-汉的半个”。"><a href="#编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串，但要保证汉字不被截取半个，-如“我ABC”，4，应该截取“我AB”，输入“我ABC汉DEF”，6，应该输出“我ABC”，而不是“我ABC-汉的半个”。" class="headerlink" title="编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串，但要保证汉字不被截取半个， 如“我ABC”，4，应该截取“我AB”，输入“我ABC汉DEF”，6，应该输出“我ABC”，而不是“我ABC+汉的半个”。"></a>编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串，但要保证汉字不被截取半个， 如“我ABC”，4，应该截取“我AB”，输入“我ABC汉DEF”，6，应该输出“我ABC”，而不是“我ABC+汉的半个”。</h3><p>分析：字符串打散成字节之后输出的字节值变成了正数和负数，字符为一个正数，汉字为两个负数<br>所以为了不输出半个汉字，可以判断负数的个数，然后确定截取数到底是多少，通过new String(buf,0,len)的构造方法把字节转换成字符串</p>
<pre><code>import java.util.Scanner;

public class T {
    public static void main(String[] args) {
        Scanner scan=new Scanner(System.in);
        while(true) {
            System.out.println(&quot;请输入一个带中文的字符串，和要截取的字节数：&quot;);
            String str=scan.next();
            int num=scan.nextInt();

            byte[] buf=str.getBytes();
            if(num&lt;=buf.length) {
                System.out.println(&quot;输入正确，即将截取字符串...&quot;);
                int times=0;
                for(int i=0;i&lt;num;i++) {
                    System.out.println(buf[i]);
                    if(buf[i]&lt;0) {
                        times++;
                    }
                }
                if(times%2==1) {
                    num--;
                }
                String out=new String(buf,0,num);//字节转成字符串
                System.out.println(&quot;截取的字符串是：&quot;+out);
                System.out.println();
            }else {
                try {
                    throw new MyException(&quot;截取字节数超出字符串长度．．．&quot;);
                } catch (MyException e) {
                    e.printStackTrace();
                }
            }
        }

    }
}

class MyException extends Exception{
    public MyException(String msg) {
        super(msg);
    }
}


</code></pre><h3 id="数组中相加等于20的组合-的集合"><a href="#数组中相加等于20的组合-的集合" class="headerlink" title="数组中相加等于20的组合 的集合"></a>数组中相加等于20的组合 的集合</h3><pre><code>import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/*
*先从小到大排序 首尾相加若小于20则把小的去除（即begin指针往前(右边)移）
*首尾相加若大于20则把小的去除（即end指针往前（左边）移）
*/
public class Test_plus {
    public static void findSum(int[] a,int sum) {
        Arrays.sort(a);
        int begin=0;
        int end=a.length-1;
        while(begin&lt;end) {
            if(a[begin]+a[end]&lt;sum)
                begin++;
            else if(a[begin]+a[end]&gt;sum)
                end--;
            else {
                System.out.println(a[begin]+&quot;,&quot;+a[end]);
                begin++;
                end--;
            }
        }
    }
    public static void main(String[] args) {
        int array[]= {1,7,17,2,6,3,14};
        findSum(array, 20);
    }

}
</code></pre><h3 id="取出数组中重复最多的数"><a href="#取出数组中重复最多的数" class="headerlink" title="取出数组中重复最多的数"></a>取出数组中重复最多的数</h3><pre><code>思路：把数组中的每个元素作为key存到map中 如果map没有value 设为1 
有则value+1
然后用类似于选择排序的算法取出value 最大的那个value 的key即可

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/*
*利用map key唯一性 唯一来存储数组的原数，而每遍历map中判断出已有key（即已有相同元素）存在，则key对应的value+1
*若没有，则把元素设为key，value设为1
*/
public class Test_plus {
    public static int findMostFrequentInArray(int[] a) {
        int result = 0;
        int size = a.length;
        if(size==0)
            return Integer.MAX_VALUE;
        Map&lt;Integer,Integer&gt;m=new HashMap&lt;Integer,Integer&gt;();
        //开始遍历数组，往map中设置数组中每个元素(对应map中的key)对应出现的次数(对应map中的value)
        for(int i=0;i&lt;size;i++) {
            if(m.containsKey(a[i])) {
                m.put(a[i], m.get(a[i])+1);
            }
            else {
                m.put(a[i], 1);
            }
        }
        int most=0;
        Iterator iter = m.entrySet().iterator();
        //开始遍历 比较map中每个key对应的value，取最大值，返回
        while(iter.hasNext()) {
            Map.Entry entry = (Map.Entry) iter.next();
            int key=(Integer)entry.getKey();
            int val=(Integer)entry.getValue();
            if(val&gt;most) {
                result=key;
                most=val;
            }
        }
        return result;
    }
    public static void main(String[] args) {
        int[] array= {1,5,4,3,4,4,5,4,5,5,6,6,6,6,6};
        int maxFrequenceNum=findMostFrequentInArray(array);
        System.out.println(maxFrequenceNum);
    }

}
</code></pre><h3 id="将数组移k位右"><a href="#将数组移k位右" class="headerlink" title="将数组移k位右"></a>将数组移k位右</h3><pre><code>思路 ： 反转的算法 *3次即可
先把 第 k-n-1 反转
把0 -k-1 反转
整体反转 即可

//把数组循环右移K位
public class Test_plus {
    /*
    *数组倒序算法，循环首尾互换
    */
    public static void reverse(int[] a,int b,int e) {
        for(;b&lt;e;b++,e--) {
            int temp=a[e];
            a[e]=a[b];
            a[b]=temp;
        }
    }
    public static void shift_k(int[] a,int k) {
        int n=a.length;
        //右移k位和右移n+k位等价
        k=k%n;
        //将倒数第k个和最后一个之间的数组段对换循环
        reverse(a,n-k,n-1);
        //将第一个和第倒数第k-1个数对换
        reverse(a,0,n-k-1);
        //将第一个数和最后一个数之间的数对换
        reverse(a,0,n-1);
    }
    public static void main(String[] args) {
        int array[]= {1,2,3,4,5,6,7,8};
        shift_k(array, 2);
        for(int i=0;i&lt;array.length;i++) {
            System.out.println(array[i]+&quot;&quot;);
        }
    }

}
</code></pre><h3 id="判断两个字符串是否有相同字符（每个字母的个数也相同）组成"><a href="#判断两个字符串是否有相同字符（每个字母的个数也相同）组成" class="headerlink" title="判断两个字符串是否有相同字符（每个字母的个数也相同）组成"></a>判断两个字符串是否有相同字符（每个字母的个数也相同）组成</h3><pre><code>初始化一个字符串数组 每个位赋值为0 即 0000 0000 0000 0000...
对第一个字符串 s1 转成的每个字节 如425154 在对应位置上加1 
如4则在 第四的位置加1 0001 0000 0000 0000 ...
对第二个字符串 s2 转成的每个字节 如425154 在对应位置上则减1
最后只要 这个数组有一个元素不等于0 则说明 2个字符串不相等

import java.util.Arrays;

//空间换时间
public class Test_plus {
    public static void compare(String s1,String s2) {
        byte[]b1=s1.getBytes();
        byte[]b2=s2.getBytes();
        int[]bCount=new int[256];
        for(int i=0;i&lt;256;i++) {
            bCount[i]=0;
        }
        for(int i=0;i&lt;b1.length;i++)
            bCount[b1[i]-&#39;0&#39;]++;
        for(int i=0;i&lt;b2.length;i++)
            bCount[b2[i]-&#39;0&#39;]--;
        for(int i=0;i&lt;256;i++)
            if(bCount[i]!=0) {
                System.out.println(&quot;not equal&quot;);
                return;
            }
        System.out.println(&quot;equal&quot;);
    }
    public static void main(String[] args) {
        String s1=&quot;aaabbc&quot;;
        String s2=&quot;abcbaaa&quot;;
        compare(s1, s2);
        s1=&quot;aaaabbc&quot;;
        s2=&quot;abcbaab&quot;;
        compare(s1, s2);
    }

}
</code></pre><h3 id="找出数组中只出现1次的数"><a href="#找出数组中只出现1次的数" class="headerlink" title="找出数组中只出现1次的数"></a>找出数组中只出现1次的数</h3><pre><code>任何数字异或自己都等于0，两次重复的数字异或之后抵消，最后剩下只有1个的数字
知识点：任何数字异或0等于自身
按位与 a&amp;b 只有双方为1 才为1 
按位或 | 其中一方有1 才为1
按位异或 ^ 双方相同 为0 不同为 1
注意：本方法只适合于其他数字都出现偶次数才能用

public class Test_plus {
    public static int findNotDouble(int[] a) {
        int n=a.length;
        int result=a[0];
        int i;
        for(i=1;i&lt;n;++i)
            result ^= a[i];
        return result;
    }
    public static void main(String[] args) {
        int array[]= {1,2,3,2,4,3,5,4,1};
        int num = findNotDouble(array);
        System.out.println(num);
    }

}
</code></pre><h3 id="单词反转"><a href="#单词反转" class="headerlink" title="单词反转"></a>单词反转</h3><pre><code>思路：
实现字符串首尾反转 即对how are you 全反转 uoy era woh
再对每一个单词进行单独反转 （每读取到 &#39; &#39; 即对前面的字符串进行反转一次）
因为最后一个单词的后面没有 &#39; &#39; 所以需要单独反转


//数组中只有一个数组出现过1次，其他的都出现了3次
public class s {
    //把数组首尾元素交换
    public void swap(char[] cArr,int front,int end) {
        while(front&lt;end) {
            char tmp=cArr[end];
            cArr[end]=cArr[front];
            cArr[front]=tmp;
            front++;
            end--;
        }
    }
    public String swapWords(String s) {
        //对how are you 全反转 uoy era woh
        char[] cArr=s.toCharArray();
        swap(cArr,0,cArr.length-1);
        //对 当个单词进行反转 uoy - you; era - are ; woh -how(找不到 &#39; &#39;  无法反转)
        int begin=0;
        for(int i=1;i&lt;cArr.length;i++) {
        if(cArr[i]==&#39; &#39;) {
            swap(cArr,begin,i-1);
            begin=i+1;
        }
    }
        //所以要把最后一个单词单独反转 woh -how
    swap(cArr,begin,cArr.length-1);
    return new String(cArr);
    }
    public static void main(String[] args) {
        String str=&quot;how are you&quot;;
            System.out.println(new s().swapWords(str));
    }

}
</code></pre><h3 id="数组中2个元素的最小距离"><a href="#数组中2个元素的最小距离" class="headerlink" title="数组中2个元素的最小距离"></a>数组中2个元素的最小距离</h3><pre><code># 思路 ： 当同时找到2个元素时才开始比较两者之间的距离 使用最新的下标进行比较

import java.util.concurrent.atomic.AtomicInteger;

//数组中只有一个数组出现过1次，其他的都出现了3次
public class s {
    private static int min(int a,int b) {
        return a&gt;b?b:a;
    }
    public static int minDistance(int[] a,int n1,int n2) {
        if(a==null)
            return Integer.MIN_VALUE;
        int len=a.length;
        int n1_index=-1;
        int n2_index=-1;
        int min_dist=Integer.MIN_VALUE+1;
        System.out.println(min_dist);
        System.out.println(Math.abs(min_dist));
        for(int i=0;i&lt;len;++i) {
            //当首次第一个元素与第二个元素同时存在时才执行下面语句
            if(a[i]==n1) {
                n1_index=i;
                if(n2_index&gt;=0)
                    min_dist=min(Math.abs(min_dist),Math.abs(n1_index-n2_index));
                System.out.println(min_dist);
            }
            if(a[i]==n2) {
                n2_index=i;
                if(n1_index&gt;=0)
                    min_dist=min(Math.abs(min_dist),Math.abs(n2_index-n1_index));
                System.out.println(min_dist);
            }
        }
        return min_dist;
    }
    public static void main(String[] args) {
        int[] a= {0,1,2,3,4,5,6,7,8};
        System.out.println(minDistance(a, 0, 7));

    }

}
</code></pre><h3 id="求数组第二大的数（选择排序）"><a href="#求数组第二大的数（选择排序）" class="headerlink" title="求数组第二大的数（选择排序）"></a>求数组第二大的数（选择排序）</h3><pre><code>定义一个最大 和第二大的数 
每次循环都判断数组中是否有比最大的数大的有则交换两者的值
同时 把原来最大数的值赋值给第二大的


public class SecondMax {
    public static int FindSecMax(int[] data) {
        int count = data.length;
        int maxnumber = data[0];
        int sec_max = Integer.MIN_VALUE;
        for(int i = 1;i&lt;count;i++) {
            if(data[i]&gt;maxnumber) {
                sec_max = maxnumber;
                maxnumber=data[i];
            }
            else {
                if(data[i]&gt;sec_max)
                    sec_max = data[i];
            }
        }
        return sec_max;
    }
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        int[] array = {7,3,19,40,4,7,1};
        System.out.println(FindSecMax(array));
    }

}
</code></pre><h3 id="反射机制示例"><a href="#反射机制示例" class="headerlink" title="反射机制示例"></a>反射机制示例</h3><pre><code>/*获取class类*/
*class.forName(&quot;类的路径&quot;)
*类名.class
*实例名.getClass()
*/
class Base {
     public void f() {
         System.out.println(&quot;Base&quot;);
     }
}
class Sub extends Base{
     public void f() {
         System.out.println(&quot;Sub&quot;);
     }
}

public class Test_Base {

    public static void main(String[] args) {
        try {
            Class c = Class.forName(&quot;Sub&quot;);
            Base b = (Base)c.newInstance();
            b.f();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}
</code></pre><h3 id="HashMap可插入相同key的错觉-hashcode不同-equals-相等"><a href="#HashMap可插入相同key的错觉-hashcode不同-equals-相等" class="headerlink" title="HashMap可插入相同key的错觉(hashcode不同 equals 相等)"></a>HashMap可插入相同key的错觉(hashcode不同 equals 相等)</h3><pre><code>test1()是正常情况：当插入 相同key 时 后者会把前者覆盖
test2()是因为插入的key p1 和 p2是2个实例对象 虽然他们在内存中的首地址不同，但他们的实际内容是相同的
所以p1和p2 的 Person类必须实现 hashcode 和equals方法 以防止 插入相同内容的key


import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

public class TestPerson {
    public static void test1() {
        System.out.println(&quot;User user defined class as key&quot;);
        HashMap&lt;String,String&gt;hm = new HashMap&lt;String,String&gt;();
        hm.put(&quot;aaa&quot;,&quot;bbb&quot;);
        hm.put(&quot;aaa&quot;,&quot;ccc&quot;);
        Iterator iter = hm.entrySet().iterator();
        while(iter.hasNext()) {
            Map.Entry entry = (Map.Entry)iter.next();
            String key = (String)entry.getKey();
            String val = (String)entry.getValue();
            System.out.println(key+&quot;     &quot;+val);
        }
    }
    public static void test2(){
        System.out.println(&quot;Use String as Key:&quot;);
        HashMap&lt;Person,String&gt;hm = new HashMap&lt;Person,String&gt;();
        Person p1 = new Person(&quot;111&quot;, &quot;name1&quot;);
        Person p2 = new Person(&quot;111&quot;, &quot;name1&quot;);
        hm.put(p1,&quot;address1&quot;);
        hm.put(p2,&quot;address2&quot;);
        Iterator iter = hm.entrySet().iterator();
        while(iter.hasNext()) {
            Map.Entry entry = (Map.Entry)iter.next();
            Person key = (Person)entry.getKey();
            String val = (String)entry.getValue();
            System.out.println(key+&quot;     &quot;+val);
        }

    }
    public static void main(String[] args) {
        // TODO Auto-generated method stub
        test1();
        System.out.println(&quot; &quot;);
        test2();
    }

}
实现 hashcode和equals


import java.util.*;
 class Person {
     String id;
     String name;
     public int hashCode() {
         return id.hashCode();
     }
     public Person(String id,String name) {
         this.id = id;
         this.name = name;
     }
     public String toString() {
         return &quot;id =&quot;+id+&quot;,name = &quot;+name;
     }
     public boolean equals(Object obj) {
            Person p = (Person) obj;
            if(p.id.equals(this.id))
                return true;
            else
                return false;
        }
}
</code></pre><h3 id="斐波那契函数"><a href="#斐波那契函数" class="headerlink" title="斐波那契函数"></a><strong>斐波那契函数</strong></h3><pre><code>public class Demo2 {
    // 定义三个变量方法
    public static void main(String[] args) {
        int a = 1, b = 1, c = 0;
        System.out.println(&quot;斐波那契数列前20项为：&quot;);
        System.out.print(a + &quot;\t&quot; + b + &quot;\t&quot;);
        //因为前面还有两个1、1 所以i&lt;=18
        for (int i = 1; i &lt;= 18; i++) {
            c = a + b;
            a = b;
            b = c;
            System.out.print(c + &quot;\t&quot;);
            if ((i + 2) % 5 == 0)
                System.out.println();
        }
    }

}

</code></pre>
            </div>
            <hr>

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone, qq, weibo, douban"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            <div class="reprint">
                <p>
                    <span class="reprint-tip">
                        <i class="fa fa-exclamation-circle"></i>&nbsp;&nbsp;Reprint please specify:
                    </span>
                    <a href="http://viabcde.github.io" class="b-link-green">Fox</a>
                    <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                    <a href="/2018/09/17/2018-09-17-面试/" class="b-link-green">（记）面试题目</a>
                </p>
            </div>
        </div>
    </div>

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2018/09/17/2018-09-17-java一些奇奇怪怪的错误/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/7.jpg" class="responsive-img" alt="（术）Java编程出现的错误对应的解决方法">
                        
                        <span class="card-title">（术）Java编程出现的错误对应的解决方法</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">error: could not open  D:\java\jre1.8\lib\amd64\jvm.cfg解决方法：把java的环境变量%JAVA_HOME%/bin上移到最上面
优化     
查看网页源代码Ctrl+U
测试浏览器是</div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2018-09-17
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/编程/" class="post-category" target="_blank">
                                    编程
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/操作/" target="_blank">
                        <span class="chip bg-color">操作</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2018/09/17/2018-09-17-类库/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/1.jpg" class="responsive-img" alt="（术）常用类库">
                        
                        <span class="card-title">（术）常用类库</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">                                            
Java类库概念：Java的应用程序接口(API)以包的形式来组织，每个包提供了大量的相关类、接口和异常处理类，这些包的集合就是Java的类库

包名</div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2018-09-17
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/编程/" class="post-category" target="_blank">
                                    编程
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/类库/" target="_blank">
                        <span class="chip bg-color">类库</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            本站由&copy;<a href="https://blinkfox.github.io/" target="_blank">Blinkfox</a>基于
            <a href="https://hexo.io/" target="_blank">Hexo</a> 的
            <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">hexo-theme-matery</a>主题搭建.

            

            
			
                <br>
                
                <span id="busuanzi_container_site_pv">
                    <i class="fa fa-heart-o"></i>
                    本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
                </span>
                
                
                <span id="busuanzi_container_site_uv">
                    <i class="fa fa-users"></i>
                    次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
                </span>
                
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">


    <a href="mailto:437230257@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=437230257" class="tooltipped" data-tooltip="QQ联系我: 437230257" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>


</div>
    </div>
</footer>

<div class="progress-bar"></div>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword" class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->



    <script src="/libs/others/clicklove.js"></script>


    <script async src="/libs/others/busuanzi.pure.mini.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":60,"height":100},"mobile":{"show":true},"search":null,"path":"search.xml","field":"post","log":false});</script></body>
</html>